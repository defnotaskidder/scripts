 --[[
╔═══════════════════════════════════════════════════════════════════════════════╗
║                                                                               ║
║   ██████╗ ██████╗ ██╗   ██╗███╗   ██╗ ██████╗                                 ║
║   ██╔══██╗██╔══██╗██║   ██║████╗  ██║██╔═══██╗                                ║
║   ██████╔╝██████╔╝██║   ██║██╔██╗ ██║██║   ██║                                ║
║   ██╔══██╗██╔══██╗██║   ██║██║╚██╗██║██║   ██║                                ║
║   ██████╔╝██║  ██║╚██████╔╝██║ ╚████║╚██████╔╝                                ║
║   ╚═════╝ ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝                                 ║
║                                                                               ║
║                    SOUTH BRONX - FULL FEATURE SCRIPT                          ║
║                         10,000+ Lines Edition                                 ║
║                                                                               ║
║   Features:                                                                   ║
║   - All Original Pastebins                                                    ║
║   - Full ESP System (Box, Name, Health, Distance, Skeleton, Tracer)          ║
║   - Advanced Aimbot with FOV Circle                                          ║
║   - Silent Aim & Wall Bang                                                   ║
║   - Complete Gun Modifications                                                ║
║   - Player Modifications (Fly, Noclip, Speed, etc)                           ║
║   - Auto Farms (Box, Chips, Marshmallow, Rob)                                ║
║   - Teleport System with Waypoints                                           ║
║   - Server Management (Hop, Rejoin, Anti-AFK)                                ║
║   - Full Customization Options                                                ║
║                                                                               ║
║   UI: Pepsi's UI Library (rbxassetid://7657867786)                           ║
║   Game: Bruno | South Bronx (PlaceId: 3351674303)                            ║
║                                                                               ║
╚═══════════════════════════════════════════════════════════════════════════════╝
]]--

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 1: SERVICES AND VARIABLES
═══════════════════════════════════════════════════════════════════════════ ]]--

-- Core Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local TeleportService = game:GetService("TeleportService")
local ProximityPromptService = game:GetService("ProximityPromptService")
local HttpService = game:GetService("HttpService")
local Lighting = game:GetService("Lighting")
local StarterGui = game:GetService("StarterGui")
local VirtualUser = game:GetService("VirtualUser")
local PathfindingService = game:GetService("PathfindingService")
local SoundService = game:GetService("SoundService")
local MarketplaceService = game:GetService("MarketplaceService")
local CoreGui = game:GetService("CoreGui")
local TextService = game:GetService("TextService")
local GuiService = game:GetService("GuiService")
local ContextActionService = game:GetService("ContextActionService")
local Debris = game:GetService("Debris")
local PhysicsService = game:GetService("PhysicsService")
local CollectionService = game:GetService("CollectionService")
local Chat = game:GetService("Chat")
local Teams = game:GetService("Teams")
local BadgeService = game:GetService("BadgeService")
local InsertService = game:GetService("InsertService")
local GamePassService = game:GetService("GamePassService")
local NotificationService = game:GetService("NotificationService")
local PolicyService = game:GetService("PolicyService")
local LocalizationService = game:GetService("LocalizationService")
local MemStorageService = game:GetService("MemStorageService")
local StatsService = game:GetService("Stats")
local LogService = game:GetService("LogService")
local ScriptContext = game:GetService("ScriptContext")

-- Player Variables
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = Workspace.CurrentCamera
local LocalCharacter = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = LocalCharacter and LocalCharacter:FindFirstChildOfClass("Humanoid")
local HumanoidRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")

-- Game Variables
local GamePlaceId = game.PlaceId
local GameJobId = game.JobId
local GameName = "Bruno | South Bronx"

-- Global Settings Table
getgenv().BrunoSettings = getgenv().BrunoSettings or {
    -- Player Settings
    WalkSpeed = 16,
    JumpPower = 50,
    Gravity = 196.2,
    HipHeight = 2,
    FOV = 70,
    
    -- Fly Settings
    FlyEnabled = false,
    FlySpeed = 50,
    
    -- Noclip Settings
    NoclipEnabled = false,
    
    -- Invisible Settings
    InvisibleEnabled = false,
    
    -- GodMode Settings
    GodModeEnabled = false,
    
    -- Infinite Jump
    InfiniteJumpEnabled = false,
    
    -- Hitbox Settings
    HitboxEnabled = false,
    HitboxSize = 15,
    HitboxTransparency = 0.5,
    
    -- Aimbot Settings
    AimbotEnabled = false,
    AimbotKey = Enum.UserInputType.MouseButton2,
    AimbotPart = "Head",
    AimbotFOV = 150,
    AimbotSmoothness = 0.5,
    AimbotTeamCheck = false,
    AimbotVisibleCheck = true,
    AimbotPrediction = 0,
    AimbotLocked = false,
    AimbotLockedTarget = nil,
    
    -- FOV Circle Settings
    FOVCircleEnabled = false,
    FOVCircleColor = Color3.fromRGB(255, 255, 255),
    FOVCircleThickness = 1,
    FOVCircleFilled = false,
    FOVCircleTransparency = 0.7,
    FOVCircleSides = 64,
    
    -- ESP Settings
    ESPEnabled = false,
    ESPBoxEnabled = false,
    ESPNameEnabled = false,
    ESPHealthEnabled = false,
    ESPDistanceEnabled = false,
    ESPTracerEnabled = false,
    ESPSkeletonEnabled = false,
    ESPHeadDotEnabled = false,
    ESPWeaponEnabled = false,
    ESPArrowsEnabled = false,
    ESPTeamCheck = false,
    ESPBoxColor = Color3.fromRGB(255, 0, 0),
    ESPNameColor = Color3.fromRGB(255, 255, 255),
    ESPTracerColor = Color3.fromRGB(255, 0, 0),
    ESPSkeletonColor = Color3.fromRGB(255, 255, 255),
    ESPTracerOrigin = "Bottom",
    
    -- Chams Settings
    ChamsEnabled = false,
    ChamsColor = Color3.fromRGB(255, 0, 0),
    ChamsFillTransparency = 0.5,
    ChamsOutlineTransparency = 0,
    
    -- Highlight Settings
    HighlightEnabled = false,
    HighlightFillColor = Color3.fromRGB(255, 0, 0),
    HighlightOutlineColor = Color3.fromRGB(255, 255, 255),
    HighlightFillTransparency = 0.5,
    HighlightOutlineTransparency = 0,
    
    -- Crosshair Settings
    CrosshairEnabled = false,
    CrosshairSize = 10,
    CrosshairGap = 5,
    CrosshairThickness = 2,
    CrosshairColor = Color3.fromRGB(0, 255, 0),
    CrosshairDot = false,
    CrosshairDotSize = 2,
    
    -- Radar Settings
    RadarEnabled = false,
    RadarSize = 150,
    RadarScale = 10,
    RadarPositionX = 100,
    RadarPositionY = 100,
    
    -- Gun Mod Settings
    InfiniteAmmoEnabled = false,
    RapidFireEnabled = false,
    RapidFireRate = 0.05,
    NoRecoilEnabled = false,
    NoSpreadEnabled = false,
    QuickReloadEnabled = false,
    InfiniteRangeEnabled = false,
    
    -- Farm Settings
    BoxAutoFarmEnabled = false,
    ChipsAutoFarmEnabled = false,
    MarshmallowAutoFarmEnabled = false,
    RobFarmEnabled = false,
    AutoCollectEnabled = false,
    AutoCollectRadius = 50,
    
    -- Teleport Settings
    SavedWaypoints = {},
    WaypointCount = 0,
    
    -- Target Settings
    TargetPlayer = nil,
    TPLoopEnabled = false,
    FlingEnabled = false,
    FlingPower = 10000,
    AnnoyEnabled = false,
    OrbitEnabled = false,
    OrbitRadius = 10,
    OrbitSpeed = 2,
    
    -- Misc Settings
    AntiAFKEnabled = false,
    AntiVoidEnabled = false,
    AntiVoidHeight = -100,
    AutoRespawnEnabled = false,
    AutoRespawnDelay = 1,
    FakeLagEnabled = false,
    FakeLagAmount = 0.5,
    SpinEnabled = false,
    SpinSpeed = 10,
    ChatSpamEnabled = false,
    ChatSpamMessage = "",
    ChatSpamDelay = 1,
    
    -- Debug Settings
    FPSEnabled = false,
    PingEnabled = false,
    PositionEnabled = false,
    VelocityEnabled = false,
    
    -- Webhook Settings
    WebhookURL = "",
    WebhookOnDeath = false,
}

local Settings = getgenv().BrunoSettings

-- Connections Storage
local Connections = {}

-- ESP Objects Storage
local ESPObjects = {}

-- Chams Storage
local ChamsFolder = nil

-- Drawing Objects
local FOVCircle = nil
local CrosshairLines = {}
local RadarFrame = nil
local RadarCenterDot = nil
local RadarDots = {}
local ArrowDrawings = {}
local DebugLabels = {}

-- Fly Variables
local FlyBodyVelocity = nil
local FlyBodyGyro = nil

-- Animation Variables
local CurrentAnimation = nil

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 2: UTILITY FUNCTIONS
═══════════════════════════════════════════════════════════════════════════ ]]--

-- Get Character
local function getCharacter()
    return LocalPlayer.Character
end

-- Get Humanoid
local function getHumanoid()
    local char = getCharacter()
    return char and char:FindFirstChildOfClass("Humanoid")
end

-- Get HumanoidRootPart
local function getHRP()
    local char = getCharacter()
    return char and char:FindFirstChild("HumanoidRootPart")
end

-- Get Head
local function getHead()
    local char = getCharacter()
    return char and char:FindFirstChild("Head")
end

-- Get Backpack
local function getBackpack()
    return LocalPlayer:FindFirstChild("Backpack")
end

-- Get Equipped Tool
local function getEquippedTool()
    local char = getCharacter()
    if char then
        for _, item in pairs(char:GetChildren()) do
            if item:IsA("Tool") then
                return item
            end
        end
    end
    return nil
end

-- Get All Tools
local function getAllTools()
    local tools = {}
    local char = getCharacter()
    local backpack = getBackpack()
    
    if char then
        for _, item in pairs(char:GetChildren()) do
            if item:IsA("Tool") then
                table.insert(tools, item)
            end
        end
    end
    
    if backpack then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                table.insert(tools, item)
            end
        end
    end
    
    return tools
end

-- Find Player by Name
local function findPlayer(name)
    if not name or name == "" then return nil end
    
    local lowerName = string.lower(name)
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local playerName = string.lower(player.Name)
            local displayName = player.DisplayName and string.lower(player.DisplayName) or ""
            
            if string.sub(playerName, 1, #lowerName) == lowerName then
                return player
            elseif string.sub(displayName, 1, #lowerName) == lowerName then
                return player
            elseif string.find(playerName, lowerName) then
                return player
            elseif string.find(displayName, lowerName) then
                return player
            end
        end
    end
    
    return nil
end

-- Get All Player Names
local function getAllPlayerNames()
    local names = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(names, player.DisplayName or player.Name)
        end
    end
    return names
end

-- Get Closest Player
local function getClosestPlayer(maxDistance, fovCheck, teamCheck, visibleCheck)
    local closest = nil
    local shortestDist = maxDistance or math.huge
    
    local myHRP = getHRP()
    if not myHRP then return nil end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            -- Team Check
            if teamCheck and player.Team == LocalPlayer.Team then
                continue
            end
            
            local targetHRP = player.Character:FindFirstChild("HumanoidRootPart")
            local targetHead = player.Character:FindFirstChild("Head")
            local targetHum = player.Character:FindFirstChildOfClass("Humanoid")
            
            if targetHRP and targetHum and targetHum.Health > 0 then
                -- FOV Check
                if fovCheck then
                    local screenPos, onScreen = Camera:WorldToScreenPoint(targetHead and targetHead.Position or targetHRP.Position)
                    if not onScreen then continue end
                    
                    local mousePos = UserInputService:GetMouseLocation()
                    local fovDist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                    
                    if fovDist > Settings.AimbotFOV then continue end
                end
                
                -- Visible Check
                if visibleCheck then
                    local rayParams = RaycastParams.new()
                    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
                    rayParams.FilterDescendantsInstances = {LocalCharacter, player.Character}
                    
                    local origin = Camera.CFrame.Position
                    local direction = (targetHRP.Position - origin)
                    local result = Workspace:Raycast(origin, direction, rayParams)
                    
                    if result then continue end
                end
                
                -- Distance Check
                local dist = (targetHRP.Position - myHRP.Position).Magnitude
                if dist < shortestDist then
                    shortestDist = dist
                    closest = player
                end
            end
        end
    end
    
    return closest, shortestDist
end

-- Get Closest Player to Mouse (for aimbot)
local function getClosestPlayerToMouse()
    local closest = nil
    local shortestDist = Settings.AimbotFOV
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            if Settings.AimbotTeamCheck and player.Team == LocalPlayer.Team then
                continue
            end
            
            local targetPart = player.Character:FindFirstChild(Settings.AimbotPart) or player.Character:FindFirstChild("Head")
            local targetHum = player.Character:FindFirstChildOfClass("Humanoid")
            
            if targetPart and targetHum and targetHum.Health > 0 then
                local screenPos, onScreen = Camera:WorldToScreenPoint(targetPart.Position)
                
                if onScreen then
                    local mousePos = UserInputService:GetMouseLocation()
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                    
                    if dist < shortestDist then
                        -- Visibility check
                        if Settings.AimbotVisibleCheck then
                            local rayParams = RaycastParams.new()
                            rayParams.FilterType = Enum.RaycastFilterType.Blacklist
                            rayParams.FilterDescendantsInstances = {LocalCharacter, player.Character}
                            
                            local origin = Camera.CFrame.Position
                            local direction = (targetPart.Position - origin)
                            local result = Workspace:Raycast(origin, direction, rayParams)
                            
                            if result then continue end
                        end
                        
                        shortestDist = dist
                        closest = player
                    end
                end
            end
        end
    end
    
    return closest
end

-- Tween to Position
local function tweenTo(position, duration)
    local hrp = getHRP()
    if not hrp then return end
    
    duration = duration or 1
    
    local tweenInfo = TweenInfo.new(
        duration,
        Enum.EasingStyle.Linear,
        Enum.EasingDirection.Out
    )
    
    local tween = TweenService:Create(hrp, tweenInfo, {CFrame = CFrame.new(position)})
    tween:Play()
    
    return tween
end

-- Send Notification
local function sendNotification(title, text, duration)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = title or "Bruno",
            Text = text or "",
            Duration = duration or 3
        })
    end)
end

-- Send Webhook
local function sendWebhook(url, data)
    if not url or url == "" then return end
    
    pcall(function()
        local payload = HttpService:JSONEncode({
            embeds = {{
                title = data.title or "Bruno Notification",
                description = data.description or "",
                color = data.color or 16711680,
                fields = data.fields or {},
                footer = {
                    text = "Bruno | South Bronx Script"
                },
                timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }}
        })
        
        local request = (syn and syn.request) or (http and http.request) or http_request or request
        if request then
            request({
                Url = url,
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = payload
            })
        end
    end)
end

-- Copy to Clipboard
local function copyToClipboard(text)
    if setclipboard then
        setclipboard(text)
        sendNotification("Copied", "Text copied to clipboard!")
    else
        print("Clipboard: " .. text)
    end
end

-- Fire ProximityPrompt
local function firePrompt(prompt)
    if prompt and prompt:IsA("ProximityPrompt") then
        if fireproximityprompt then
            fireproximityprompt(prompt)
        else
            prompt:InputHoldBegin()
            task.wait(prompt.HoldDuration + 0.1)
            prompt:InputHoldEnd()
        end
    end
end

-- Get All ProximityPrompts
local function getAllPrompts()
    local prompts = {}
    for _, v in pairs(Workspace:GetDescendants()) do
        if v:IsA("ProximityPrompt") then
            table.insert(prompts, v)
        end
    end
    return prompts
end

-- Safe Destroy
local function safeDestroy(instance)
    if instance and instance.Parent then
        pcall(function()
            instance:Destroy()
        end)
    end
end

-- Create Drawing
local function createDrawing(type, properties)
    local drawing = Drawing.new(type)
    for prop, value in pairs(properties or {}) do
        pcall(function()
            drawing[prop] = value
        end)
    end
    return drawing
end

-- Disconnect All Connections
local function disconnectAll()
    for name, connection in pairs(Connections) do
        if connection and typeof(connection) == "RBXScriptConnection" then
            connection:Disconnect()
        end
        Connections[name] = nil
    end
end

-- Clean Up
local function cleanUp()
    disconnectAll()
    
    -- Clean ESP
    for player, esp in pairs(ESPObjects) do
        if esp then
            pcall(function() esp.Box:Remove() end)
            pcall(function() esp.BoxOutline:Remove() end)
            pcall(function() esp.Name:Remove() end)
            pcall(function() esp.Distance:Remove() end)
            pcall(function() esp.Health:Remove() end)
            pcall(function() esp.HealthBG:Remove() end)
            pcall(function() esp.HealthOutline:Remove() end)
            pcall(function() esp.Tracer:Remove() end)
            pcall(function() esp.HeadDot:Remove() end)
            pcall(function() esp.Weapon:Remove() end)
            if esp.Skeleton then
                for _, line in pairs(esp.Skeleton) do
                    pcall(function() line:Remove() end)
                end
            end
        end
    end
    ESPObjects = {}
    
    -- Clean Chams
    if ChamsFolder then
        safeDestroy(ChamsFolder)
        ChamsFolder = nil
    end
    
    -- Clean Drawing Objects
    if FOVCircle then
        pcall(function() FOVCircle:Remove() end)
        FOVCircle = nil
    end
    
    for _, line in pairs(CrosshairLines) do
        pcall(function() line:Remove() end)
    end
    CrosshairLines = {}
    
    if RadarFrame then
        pcall(function() RadarFrame:Remove() end)
        RadarFrame = nil
    end
    
    if RadarCenterDot then
        pcall(function() RadarCenterDot:Remove() end)
        RadarCenterDot = nil
    end
    
    for _, dot in pairs(RadarDots) do
        pcall(function() dot:Remove() end)
    end
    RadarDots = {}
    
    for _, arrow in pairs(ArrowDrawings) do
        pcall(function() arrow:Remove() end)
    end
    ArrowDrawings = {}
    
    for _, label in pairs(DebugLabels) do
        pcall(function() label:Remove() end)
    end
    DebugLabels = {}
    
    -- Stop Fly
    if FlyBodyVelocity then
        safeDestroy(FlyBodyVelocity)
        FlyBodyVelocity = nil
    end
    if FlyBodyGyro then
        safeDestroy(FlyBodyGyro)
        FlyBodyGyro = nil
    end
    
    print("Bruno Script cleaned up!")
end

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 3: CHARACTER UPDATE HANDLER
═══════════════════════════════════════════════════════════════════════════ ]]--

-- Update character references on respawn
LocalPlayer.CharacterAdded:Connect(function(char)
    LocalCharacter = char
    Humanoid = char:WaitForChild("Humanoid", 10)
    HumanoidRootPart = char:WaitForChild("HumanoidRootPart", 10)
    
    -- Re-apply settings
    if Humanoid then
        Humanoid.WalkSpeed = Settings.WalkSpeed
        Humanoid.JumpPower = Settings.JumpPower
        Humanoid.UseJumpPower = true
        
        -- Auto respawn on death
        Humanoid.Died:Connect(function()
            -- Webhook on death
            if Settings.WebhookOnDeath and Settings.WebhookURL ~= "" then
                sendWebhook(Settings.WebhookURL, {
                    title = "Player Died",
                    description = LocalPlayer.Name .. " has died!",
                    color = 16711680
                })
            end
            
            -- Auto respawn
            if Settings.AutoRespawnEnabled then
                task.wait(Settings.AutoRespawnDelay)
                pcall(function()
                    LocalPlayer:LoadCharacter()
                end)
            end
        end)
    end
    
    -- Reset states
    Settings.FlyEnabled = false
    Settings.NoclipEnabled = false
    Settings.InvisibleEnabled = false
    
    -- Clean up old instances
    if FlyBodyVelocity then safeDestroy(FlyBodyVelocity) FlyBodyVelocity = nil end
    if FlyBodyGyro then safeDestroy(FlyBodyGyro) FlyBodyGyro = nil end
    
    -- Jump on spawn to confirm script is working
    task.spawn(function()
        task.wait(0.5)
        if Humanoid then
            Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end)
end)


--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 4: LOAD UI LIBRARY
═══════════════════════════════════════════════════════════════════════════ ]]--

local UiLibrary = loadstring(game:GetObjects("rbxassetid://7657867786")[1].Source)()

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 5: CREATE MAIN WINDOW
═══════════════════════════════════════════════════════════════════════════ ]]--

local MainWindow = UiLibrary:CreateWindow({
    ["Themeable"] = {
        ["Info"] = "Thanks For Using!",
        ["Credit"] = false
    },
    ["Name"] = "Bruno | South Bronx",
    ["DefaultTheme"] = '{"__Designer.Colors.topGradient":"232323","__Designer.Settings.ShowHideKey":"Enum.KeyCode.RShift","__Designer.Colors.section":"B0AFB0","__Designer.Colors.hoveredOptionBottom":"2D2D2D","__Designer.Background.ImageAssetID":"rbxassetid://0","__Designer.Colors.innerBorder":"493F49","__Designer.Colors.unselectedOption":"282828","__Designer.Files.WorkspaceFile":"DodgeBros","__Designer.Colors.unhoveredOptionTop":"323232","__Designer.Colors.outerBorder":"0F0F0F","__Designer.Background.ImageColor":"FFFFFF","__Designer.Colors.tabText":"B9B9B9","__Designer.Colors.elementBorder":"141414","__Designer.Colors.sectionBackground":"232222","__Designer.Colors.selectedOption":"373737","__Designer.Colors.background":"282828","__Designer.Colors.bottomGradient":"1D1D1D","__Designer.Background.ImageTransparency":100,"__Designer.Colors.main":"FFFFFF","__Designer.Colors.elementText":"939193","__Designer.Colors.hoveredOptionTop":"414141","__Designer.Colors.otherElementText":"817F81","__Designer.Colors.unhoveredOptionBottom":"232323","__Designer.Background.UseBackgroundImage":false}'
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 6: CREATE TABS
═══════════════════════════════════════════════════════════════════════════ ]]--

local MainTab = MainWindow:CreateTab({
    ["Name"] = "General"
})

local AimbotTab = MainWindow:CreateTab({
    ["Name"] = "Aimbot"
})

local VisualsTab = MainWindow:CreateTab({
    ["Name"] = "Visuals"
})

local FarmTab = MainWindow:CreateTab({
    ["Name"] = "Farm"
})

local TeleportTab = MainWindow:CreateTab({
    ["Name"] = "Teleport"
})

local MiscTab = MainWindow:CreateTab({
    ["Name"] = "Misc"
})

local SettingsTab = MainWindow:CreateTab({
    ["Name"] = "Settings"
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 7: MAIN TAB - PLAYER SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local MainSection = MainTab:CreateSection({
    ["Name"] = "|Player|",
    ["Side"] = "Left"
})

-- Semi GodMode (PASTEBIN: a81PCdNV)
MainSection:AddToggle({
    ["StartingState"] = false,
    ["Name"] = "| Semi GodMode",
    ["Description"] = "This Enables Semi GodMode.",
    ["Callback"] = function(Value)
        if Value then
            Settings.GodModeEnabled = true
            loadstring(game:HttpGet("https://pastebin.com/raw/a81PCdNV"))()
        else
            Settings.GodModeEnabled = false
        end
    end
})

-- Hitbox Expander (PASTEBIN: 6zXxnvRE)
MainSection:AddToggle({
    ["StartingState"] = false,
    ["Name"] = "| Hitbox Expander",
    ["Description"] = "This Expands the Hitbox of Players.",
    ["Callback"] = function(Value)
        if Value then
            Settings.HitboxEnabled = true
            loadstring(game:HttpGet("https://pastebin.com/raw/6zXxnvRE"))()
        else
            Settings.HitboxEnabled = false
        end
    end
})

-- Forward Teleport (PASTEBIN: ZjVJQMAk)
MainSection:AddToggle({
    ["StartingState"] = false,
    ["Name"] = "| Forward Teleport ( T )",
    ["Description"] = "This Teleports You Forward.",
    ["Callback"] = function(Value)
        if Value then
            loadstring(game:HttpGet("https://pastebin.com/raw/ZjVJQMAk"))()
        end
    end
})

-- Insta-Interact (WORKING CODE)
MainSection:AddToggle({
    ["Name"] = "| Insta-Interact",
    ["Callback"] = function(Value)
        if Value then
            -- Set all current prompts to 0
            for _, prompt in pairs(getAllPrompts()) do
                prompt.HoldDuration = 0
            end
            
            -- Connect to new prompts
            Connections["InstaInteract"] = ProximityPromptService.PromptButtonHoldBegan:Connect(function(prompt)
                prompt.HoldDuration = 0
            end)
            
            sendNotification("Insta-Interact", "Enabled!")
        else
            if Connections["InstaInteract"] then
                Connections["InstaInteract"]:Disconnect()
                Connections["InstaInteract"] = nil
            end
        end
    end
})

-- Fly (PASTEBIN: TVYcXkS4)
MainSection:AddToggle({
    ["StartingState"] = false,
    ["Name"] = "| Fly ( V )",
    ["Callback"] = function(Value)
        if Value then
            Settings.FlyEnabled = true
            loadstring(game:HttpGet("https://pastebin.com/raw/TVYcXkS4"))()
        else
            Settings.FlyEnabled = false
        end
    end
})

-- Invisible (PASTEBIN: vsWgWXPY)
MainSection:AddToggle({
    ["StartingState"] = false,
    ["Name"] = "| Invisible ( X )",
    ["Callback"] = function(Value)
        if Value then
            Settings.InvisibleEnabled = true
            loadstring(game:HttpGet("https://pastebin.com/raw/vsWgWXPY"))()
        else
            Settings.InvisibleEnabled = false
        end
    end
})

-- Ctrl + Click = Delete
MainSection:AddToggle({
    ["Name"] = "| Ctrl + Click = Delete",
    ["Callback"] = function(Value)
        if Value then
            Connections["CtrlClickDelete"] = Mouse.Button1Down:Connect(function()
                if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                    local target = Mouse.Target
                    if target and not target:IsDescendantOf(LocalCharacter) then
                        safeDestroy(target)
                    end
                end
            end)
        else
            if Connections["CtrlClickDelete"] then
                Connections["CtrlClickDelete"]:Disconnect()
                Connections["CtrlClickDelete"] = nil
            end
        end
    end
})

-- Infinite Zoom
MainSection:AddToggle({
    ["Name"] = "| Infinite Zoom",
    ["Callback"] = function(Value)
        if Value then
            LocalPlayer.CameraMaxZoomDistance = math.huge
            LocalPlayer.CameraMinZoomDistance = 0
        else
            LocalPlayer.CameraMaxZoomDistance = 128
            LocalPlayer.CameraMinZoomDistance = 0.5
        end
    end
})

-- Stretch Res
local StretchConnection = nil
MainSection:AddToggle({
    ["Name"] = "| Stretch Res",
    ["Flag"] = "stretchres",
    ["Value"] = false,
    ["Callback"] = function(Value)
        if Value then
            getgenv().StretchResolution = 0.65
            StretchConnection = RunService.RenderStepped:Connect(function()
                Camera.CFrame = Camera.CFrame * CFrame.new(0, 0, 0, 1, 0, 0, 0, getgenv().StretchResolution, 0, 0, 0, 1)
            end)
        else
            if StretchConnection then
                StretchConnection:Disconnect()
                StretchConnection = nil
            end
        end
    end
})

-- Call-All
MainSection:AddToggle({
    ["Name"] = "| Call-All",
    ["Side"] = "Left",
    ["Callback"] = function(Value)
        if Value then
            local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents")
            if RemoteEvents then
                local PhoneRemote = RemoteEvents:FindFirstChild("RE_Phone")
                if PhoneRemote then
                    for _, player in pairs(Players:GetPlayers()) do
                        if player ~= LocalPlayer then
                            PhoneRemote:FireServer("CallRequest", {["Target"] = player})
                            task.wait(1)
                            PhoneRemote:FireServer("CallResponse", {["Response"] = {true}})
                        end
                    end
                    sendNotification("Call-All", "Called all players!")
                end
            end
        end
    end
})

-- Equip All
MainSection:AddToggle({
    ["Name"] = "| Equip All",
    ["Flag"] = "EquipAll",
    ["Value"] = false,
    ["Callback"] = function(Value)
        if Value then
            local backpack = getBackpack()
            if backpack then
                for _, tool in pairs(backpack:GetChildren()) do
                    if tool:IsA("Tool") then
                        tool.Parent = LocalCharacter
                    end
                end
            end
        end
    end
})

-- Noclip
MainSection:AddToggle({
    ["Name"] = "| Noclip ( N )",
    ["Callback"] = function(Value)
        Settings.NoclipEnabled = Value
        if Value then
            Connections["Noclip"] = RunService.Stepped:Connect(function()
                if Settings.NoclipEnabled and LocalCharacter then
                    for _, part in pairs(LocalCharacter:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        else
            if Connections["Noclip"] then
                Connections["Noclip"]:Disconnect()
                Connections["Noclip"] = nil
            end
        end
    end
})

-- Infinite Jump
MainSection:AddToggle({
    ["Name"] = "| Infinite Jump",
    ["Callback"] = function(Value)
        Settings.InfiniteJumpEnabled = Value
    end
})

-- Anti Ragdoll
MainSection:AddToggle({
    ["Name"] = "| Anti Ragdoll",
    ["Callback"] = function(Value)
        if Value then
            Connections["AntiRagdoll"] = RunService.Heartbeat:Connect(function()
                local hum = getHumanoid()
                if hum then
                    hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
                    hum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
                    hum:SetStateEnabled(Enum.HumanoidStateType.GettingUp, false)
                end
            end)
        else
            if Connections["AntiRagdoll"] then
                Connections["AntiRagdoll"]:Disconnect()
                Connections["AntiRagdoll"] = nil
            end
        end
    end
})

-- No Fall Damage
MainSection:AddToggle({
    ["Name"] = "| No Fall Damage",
    ["Callback"] = function(Value)
        local hum = getHumanoid()
        if hum then
            hum:SetStateEnabled(Enum.HumanoidStateType.Freefall, not Value)
        end
    end
})

-- Speed Slider
MainSection:AddSlider({
    ["Min"] = 0,
    ["Max"] = 200,
    ["Name"] = "Adjust Speed",
    ["llegalInput"] = false,
    ["Value"] = 16,
    ["Decimals"] = 1,
    ["Flag"] = "SpeedSlider",
    ["Callback"] = function(Value)
        Settings.WalkSpeed = Value
        local hum = getHumanoid()
        if hum then
            hum.WalkSpeed = Value
        end
    end
})

-- Jump Power Slider
MainSection:AddSlider({
    ["Min"] = 0,
    ["Max"] = 500,
    ["Name"] = "Jump Power",
    ["llegalInput"] = false,
    ["Value"] = 50,
    ["Decimals"] = 0,
    ["Flag"] = "JumpSlider",
    ["Callback"] = function(Value)
        Settings.JumpPower = Value
        local hum = getHumanoid()
        if hum then
            hum.JumpPower = Value
            hum.UseJumpPower = true
        end
    end
})

-- FOV Slider
MainSection:AddSlider({
    ["Min"] = 30,
    ["Max"] = 120,
    ["Name"] = "Adjust FOV",
    ["llegalInput"] = false,
    ["Value"] = 70,
    ["Decimals"] = 1,
    ["Flag"] = "FOVSlider",
    ["Callback"] = function(Value)
        Settings.FOV = Value
        Camera.FieldOfView = Value
    end
})

-- Gravity Slider
MainSection:AddSlider({
    ["Min"] = 0,
    ["Max"] = 500,
    ["Name"] = "Gravity",
    ["llegalInput"] = false,
    ["Value"] = 196.2,
    ["Decimals"] = 1,
    ["Flag"] = "GravitySlider",
    ["Callback"] = function(Value)
        Settings.Gravity = Value
        Workspace.Gravity = Value
    end
})

-- Hip Height Slider
MainSection:AddSlider({
    ["Min"] = 0,
    ["Max"] = 50,
    ["Name"] = "Hip Height",
    ["llegalInput"] = false,
    ["Value"] = 2,
    ["Decimals"] = 1,
    ["Flag"] = "HipSlider",
    ["Callback"] = function(Value)
        Settings.HipHeight = Value
        local hum = getHumanoid()
        if hum then
            hum.HipHeight = Value
        end
    end
})

-- Fix Floor Button
MainSection:AddButton({
    ["Name"] = "Fix-Floor",
    ["Callback"] = function()
        local Floor = Workspace:FindFirstChild("Floor")
        if Floor then
            Floor.Size = Vector3.new(5000, 1, 5000)
            Floor.Position = Vector3.new(0, 0, 0)
            Floor.Anchored = true
            sendNotification("Floor Fixed", "Floor has been fixed!")
        end
    end
})

-- Reset Character Button
MainSection:AddButton({
    ["Name"] = "Reset Character",
    ["Callback"] = function()
        local hum = getHumanoid()
        if hum then
            hum.Health = 0
        end
    end
})


--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 8: MAIN TAB - KILL PLAYER SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local KillSection = MainTab:CreateSection({
    ["Name"] = "|Kill Player|",
    ["Side"] = "Right"
})

-- Target Name Textbox
KillSection:AddTextbox({
    ["Name"] = "Tp To Player (Stop = L)",
    ["Value"] = "",
    ["Flag"] = "TargetName",
    ["Callback"] = function(Value)
        local target = findPlayer(Value)
        if target then
            Settings.TargetPlayer = target
            Settings.TPLoopEnabled = true
            
            spawn(function()
                while Settings.TPLoopEnabled and Settings.TargetPlayer and Settings.TargetPlayer.Character do
                    local targetHRP = Settings.TargetPlayer.Character:FindFirstChild("HumanoidRootPart")
                    local myHRP = getHRP()
                    
                    if targetHRP and myHRP then
                        myHRP.CFrame = targetHRP.CFrame * CFrame.new(0, 0, -3)
                    end
                    
                    task.wait(0.3)
                end
            end)
            
            sendNotification("TP Loop", "Now teleporting to " .. target.Name)
        else
            sendNotification("Error", "Player not found!")
        end
    end
})

-- Fling Target Name
KillSection:AddTextbox({
    ["Name"] = "Fling Target Name",
    ["Value"] = "",
    ["Flag"] = "FlingTargetName",
    ["Callback"] = function(Value)
        local target = findPlayer(Value)
        if target then
            Settings.TargetPlayer = target
            sendNotification("Target Set", "Fling target: " .. target.Name)
        end
    end
})

-- Fling Power Slider
KillSection:AddSlider({
    ["Min"] = 1000,
    ["Max"] = 100000,
    ["Name"] = "Fling Power",
    ["Value"] = 10000,
    ["Decimals"] = 0,
    ["Flag"] = "FlingPower",
    ["Callback"] = function(Value)
        Settings.FlingPower = Value
    end
})

-- Fling Player Toggle
KillSection:AddToggle({
    ["Name"] = "| Fling Player",
    ["Callback"] = function(Value)
        Settings.FlingEnabled = Value
        
        if Value and Settings.TargetPlayer and Settings.TargetPlayer.Character then
            spawn(function()
                while Settings.FlingEnabled and Settings.TargetPlayer and Settings.TargetPlayer.Character do
                    local targetHRP = Settings.TargetPlayer.Character:FindFirstChild("HumanoidRootPart")
                    local myHRP = getHRP()
                    
                    if targetHRP and myHRP then
                        myHRP.CFrame = targetHRP.CFrame
                        myHRP.Velocity = Vector3.new(
                            math.random(-Settings.FlingPower, Settings.FlingPower),
                            Settings.FlingPower,
                            math.random(-Settings.FlingPower, Settings.FlingPower)
                        )
                        myHRP.RotVelocity = Vector3.new(
                            math.random(-100, 100),
                            math.random(-100, 100),
                            math.random(-100, 100)
                        )
                    end
                    
                    task.wait()
                end
            end)
        end
    end
})

-- Annoy Player Toggle
KillSection:AddToggle({
    ["Name"] = "| Annoy Player",
    ["Callback"] = function(Value)
        Settings.AnnoyEnabled = Value
        
        if Value and Settings.TargetPlayer and Settings.TargetPlayer.Character then
            spawn(function()
                while Settings.AnnoyEnabled and Settings.TargetPlayer and Settings.TargetPlayer.Character do
                    local targetHRP = Settings.TargetPlayer.Character:FindFirstChild("HumanoidRootPart")
                    local myHRP = getHRP()
                    
                    if targetHRP and myHRP then
                        myHRP.CFrame = targetHRP.CFrame * CFrame.new(
                            math.random(-5, 5),
                            0,
                            math.random(-5, 5)
                        )
                    end
                    
                    task.wait(0.2)
                end
            end)
        end
    end
})

-- Orbit Player Toggle
KillSection:AddToggle({
    ["Name"] = "| Orbit Player",
    ["Callback"] = function(Value)
        Settings.OrbitEnabled = Value
        
        if Value and Settings.TargetPlayer and Settings.TargetPlayer.Character then
            local angle = 0
            spawn(function()
                while Settings.OrbitEnabled and Settings.TargetPlayer and Settings.TargetPlayer.Character do
                    local targetHRP = Settings.TargetPlayer.Character:FindFirstChild("HumanoidRootPart")
                    local myHRP = getHRP()
                    
                    if targetHRP and myHRP then
                        angle = angle + Settings.OrbitSpeed
                        local x = math.cos(math.rad(angle)) * Settings.OrbitRadius
                        local z = math.sin(math.rad(angle)) * Settings.OrbitRadius
                        myHRP.CFrame = targetHRP.CFrame * CFrame.new(x, 0, z)
                    end
                    
                    task.wait()
                end
            end)
        end
    end
})

-- Orbit Radius Slider
KillSection:AddSlider({
    ["Min"] = 5,
    ["Max"] = 50,
    ["Name"] = "Orbit Radius",
    ["Value"] = 10,
    ["Decimals"] = 0,
    ["Flag"] = "OrbitRadius",
    ["Callback"] = function(Value)
        Settings.OrbitRadius = Value
    end
})

-- Orbit Speed Slider
KillSection:AddSlider({
    ["Min"] = 1,
    ["Max"] = 20,
    ["Name"] = "Orbit Speed",
    ["Value"] = 2,
    ["Decimals"] = 0,
    ["Flag"] = "OrbitSpeed",
    ["Callback"] = function(Value)
        Settings.OrbitSpeed = Value
    end
})

-- Attach to Player
KillSection:AddToggle({
    ["Name"] = "| Attach to Player",
    ["Callback"] = function(Value)
        if Value and Settings.TargetPlayer and Settings.TargetPlayer.Character then
            Connections["Attach"] = RunService.Heartbeat:Connect(function()
                local targetHRP = Settings.TargetPlayer.Character:FindFirstChild("HumanoidRootPart")
                local myHRP = getHRP()
                
                if targetHRP and myHRP then
                    myHRP.CFrame = targetHRP.CFrame
                end
            end)
        else
            if Connections["Attach"] then
                Connections["Attach"]:Disconnect()
                Connections["Attach"] = nil
            end
        end
    end
})

-- Teleport to Player Button
KillSection:AddButton({
    ["Name"] = "Teleport to Target",
    ["Callback"] = function()
        if Settings.TargetPlayer and Settings.TargetPlayer.Character then
            local targetHRP = Settings.TargetPlayer.Character:FindFirstChild("HumanoidRootPart")
            local myHRP = getHRP()
            
            if targetHRP and myHRP then
                myHRP.CFrame = targetHRP.CFrame * CFrame.new(0, 0, 5)
                sendNotification("Teleported", "Teleported to " .. Settings.TargetPlayer.Name)
            end
        else
            sendNotification("Error", "No target selected!")
        end
    end
})

-- Bring Player Button
KillSection:AddButton({
    ["Name"] = "Bring Target to You",
    ["Callback"] = function()
        if Settings.TargetPlayer and Settings.TargetPlayer.Character then
            local targetHRP = Settings.TargetPlayer.Character:FindFirstChild("HumanoidRootPart")
            local myHRP = getHRP()
            
            if targetHRP and myHRP then
                targetHRP.CFrame = myHRP.CFrame * CFrame.new(0, 0, 5)
                sendNotification("Brought", "Brought " .. Settings.TargetPlayer.Name .. " to you")
            end
        else
            sendNotification("Error", "No target selected!")
        end
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 9: MAIN TAB - VIEW OPTIONS SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local ViewSection = MainTab:CreateSection({
    ["Name"] = "|View Options|",
    ["Side"] = "Right"
})

local ViewTarget = nil

-- View Target Name
ViewSection:AddTextbox({
    ["Value"] = "",
    ["Name"] = "       <-Target Name->",
    ["Callback"] = function(Value)
        ViewTarget = findPlayer(Value)
        if ViewTarget then
            sendNotification("Target Set", "View target: " .. ViewTarget.Name)
        end
    end
})

-- View Inventory
ViewSection:AddToggle({
    ["Flag"] = "TGSection_View[Inventory]",
    ["Name"] = "| View [Inventory]",
    ["Callback"] = function(Value)
        if Value and ViewTarget then
            -- Create inventory GUI
            local existingGui = LocalPlayer.PlayerGui:FindFirstChild("InventoryViewerGui")
            if existingGui then existingGui:Destroy() end
            
            local ScreenGui = Instance.new("ScreenGui")
            ScreenGui.Name = "InventoryViewerGui"
            ScreenGui.Parent = LocalPlayer.PlayerGui
            ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
            
            local Background = Instance.new("Frame")
            Background.Name = "Background"
            Background.Parent = ScreenGui
            Background.BackgroundColor3 = Color3.fromRGB(26, 26, 26)
            Background.BorderSizePixel = 2
            Background.BorderColor3 = Color3.fromRGB(0, 0, 0)
            Background.Position = UDim2.new(1, -260, 0, 20)
            Background.Size = UDim2.new(0.12, 0, 0.3, 0)
            Background.ClipsDescendants = true
            
            local UIGradient = Instance.new("UIGradient")
            UIGradient.Parent = Background
            UIGradient.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.fromRGB(42, 42, 42)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(42, 42, 42))
            })
            UIGradient.Rotation = 45
            
            local UIStroke = Instance.new("UIStroke")
            UIStroke.Parent = Background
            UIStroke.Color = Color3.fromRGB(0, 0, 0)
            UIStroke.Thickness = 2
            UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
            
            local TitleLabel = Instance.new("TextLabel")
            TitleLabel.Name = "TitleLabel"
            TitleLabel.Parent = Background
            TitleLabel.BackgroundTransparency = 1
            TitleLabel.Size = UDim2.new(1, 0, 0, 30)
            TitleLabel.Font = Enum.Font.SourceSansBold
            TitleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            TitleLabel.TextSize = 18
            TitleLabel.TextScaled = true
            TitleLabel.TextWrapped = true
            TitleLabel.TextStrokeTransparency = 0.3
            TitleLabel.Text = "Inventory: " .. ViewTarget.Name
            
            local ScrollingFrame = Instance.new("ScrollingFrame")
            ScrollingFrame.Parent = Background
            ScrollingFrame.Size = UDim2.new(1, -10, 1, -35)
            ScrollingFrame.Position = UDim2.new(0, 5, 0, 35)
            ScrollingFrame.ScrollBarThickness = 10
            ScrollingFrame.BackgroundTransparency = 1
            ScrollingFrame.ClipsDescendants = true
            
            local UIListLayout = Instance.new("UIListLayout")
            UIListLayout.Parent = ScrollingFrame
            UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
            UIListLayout.Padding = UDim.new(0, 5)
            
            local UIPadding = Instance.new("UIPadding")
            UIPadding.Parent = ScrollingFrame
            UIPadding.PaddingTop = UDim.new(0, 5)
            
            -- Add items
            local itemCount = 0
            
            -- Character items (equipped)
            if ViewTarget.Character then
                for _, item in pairs(ViewTarget.Character:GetChildren()) do
                    if item:IsA("Tool") then
                        itemCount = itemCount + 1
                        local ItemLabel = Instance.new("TextLabel")
                        ItemLabel.Name = "Item" .. itemCount
                        ItemLabel.BackgroundTransparency = 0.5
                        ItemLabel.BackgroundColor3 = Color3.fromRGB(60, 40, 40)
                        ItemLabel.BorderSizePixel = 1
                        ItemLabel.BorderColor3 = Color3.fromRGB(30, 30, 30)
                        ItemLabel.Size = UDim2.new(1, -10, 0, 22)
                        ItemLabel.Font = Enum.Font.SourceSans
                        ItemLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
                        ItemLabel.TextScaled = true
                        ItemLabel.TextSize = 14
                        ItemLabel.TextWrapped = true
                        ItemLabel.Text = "[E] " .. item.Name
                        ItemLabel.Parent = ScrollingFrame
                    end
                end
            end
            
            -- Backpack items
            local backpack = ViewTarget:FindFirstChild("Backpack")
            if backpack then
                for _, item in pairs(backpack:GetChildren()) do
                    if item:IsA("Tool") then
                        itemCount = itemCount + 1
                        local ItemLabel = Instance.new("TextLabel")
                        ItemLabel.Name = "Item" .. itemCount
                        ItemLabel.BackgroundTransparency = 0.5
                        ItemLabel.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
                        ItemLabel.BorderSizePixel = 1
                        ItemLabel.BorderColor3 = Color3.fromRGB(30, 30, 30)
                        ItemLabel.Size = UDim2.new(1, -10, 0, 22)
                        ItemLabel.Font = Enum.Font.SourceSans
                        ItemLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
                        ItemLabel.TextScaled = true
                        ItemLabel.TextSize = 14
                        ItemLabel.TextWrapped = true
                        ItemLabel.Text = item.Name
                        ItemLabel.Parent = ScrollingFrame
                    end
                end
            end
            
            ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, itemCount * 27)
            
            sendNotification("Inventory", "Viewing " .. ViewTarget.Name .. "'s inventory (" .. itemCount .. " items)")
        else
            local existingGui = LocalPlayer.PlayerGui:FindFirstChild("InventoryViewerGui")
            if existingGui then existingGui:Destroy() end
        end
    end
})

-- Spectate
local IsSpectating = false
ViewSection:AddToggle({
    ["Name"] = "| Spectate",
    ["Callback"] = function(Value)
        if Value and ViewTarget and ViewTarget.Character then
            local hum = ViewTarget.Character:FindFirstChild("Humanoid")
            if hum then
                Camera.CameraSubject = hum
                IsSpectating = true
                sendNotification("Spectating", "Now spectating " .. ViewTarget.Name)
            end
        else
            local myHum = getHumanoid()
            if myHum then
                Camera.CameraSubject = myHum
            end
            IsSpectating = false
        end
    end
})

-- View Player Stats
ViewSection:AddButton({
    ["Name"] = "| View Player Stats",
    ["Callback"] = function()
        if ViewTarget and ViewTarget.Character then
            local hum = ViewTarget.Character:FindFirstChild("Humanoid")
            local hrp = ViewTarget.Character:FindFirstChild("HumanoidRootPart")
            
            if hum and hrp then
                print("=== " .. ViewTarget.Name .. " STATS ===")
                print("Health: " .. math.floor(hum.Health) .. "/" .. hum.MaxHealth)
                print("WalkSpeed: " .. hum.WalkSpeed)
                print("JumpPower: " .. hum.JumpPower)
                print("Position: " .. tostring(hrp.Position))
                
                local myHRP = getHRP()
                if myHRP then
                    local dist = (hrp.Position - myHRP.Position).Magnitude
                    print("Distance: " .. math.floor(dist) .. " studs")
                end
                print("========================")
                
                sendNotification("Stats Printed", "Check output for " .. ViewTarget.Name .. "'s stats")
            end
        else
            sendNotification("Error", "No target selected!")
        end
    end
})

-- Refresh Player List
ViewSection:AddButton({
    ["Name"] = "| Refresh Player List",
    ["Callback"] = function()
        print("=== PLAYER LIST ===")
        for i, player in pairs(Players:GetPlayers()) do
            local status = player == LocalPlayer and "(YOU)" or ""
            print(i .. ". " .. player.Name .. " (" .. player.DisplayName .. ") " .. status)
        end
        print("===================")
        sendNotification("Player List", "Printed " .. #Players:GetPlayers() .. " players to output")
    end
})


--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 10: MAIN TAB - GUN MODS SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local GunModsSection = MainTab:CreateSection({
    ["Name"] = "|Gun Mods|",
    ["Side"] = "Left"
})

-- Infinite Ammo
GunModsSection:AddToggle({
    ["Value"] = false,
    ["Name"] = "| Infinite Ammo",
    ["Callback"] = function(Value)
        Settings.InfiniteAmmoEnabled = Value
        
        if Value then
            Connections["InfiniteAmmo"] = RunService.Heartbeat:Connect(function()
                if Settings.InfiniteAmmoEnabled then
                    for _, player in ipairs(Players:GetPlayers()) do
                        -- Backpack
                        local backpack = player:FindFirstChild("Backpack")
                        if backpack then
                            for _, tool in ipairs(backpack:GetChildren()) do
                                if tool:IsA("Tool") then
                                    local ammo = tool:FindFirstChild("Ammo")
                                    local mag = tool:FindFirstChild("Mag")
                                    local currentAmmo = tool:FindFirstChild("CurrentAmmo")
                                    local maxAmmo = tool:FindFirstChild("MaxAmmo")
                                    
                                    if ammo then ammo.Value = math.huge end
                                    if mag then mag.Value = math.huge end
                                    if currentAmmo then currentAmmo.Value = math.huge end
                                    if maxAmmo then maxAmmo.Value = math.huge end
                                end
                            end
                        end
                        
                        -- Character
                        local char = player.Character
                        if char then
                            for _, tool in ipairs(char:GetChildren()) do
                                if tool:IsA("Tool") then
                                    local ammo = tool:FindFirstChild("Ammo")
                                    local mag = tool:FindFirstChild("Mag")
                                    local currentAmmo = tool:FindFirstChild("CurrentAmmo")
                                    local maxAmmo = tool:FindFirstChild("MaxAmmo")
                                    
                                    if ammo then ammo.Value = math.huge end
                                    if mag then mag.Value = math.huge end
                                    if currentAmmo then currentAmmo.Value = math.huge end
                                    if maxAmmo then maxAmmo.Value = math.huge end
                                end
                            end
                        end
                    end
                    
                    -- Try to destroy ammo change remote
                    pcall(function()
                        local remotes = ReplicatedStorage:FindFirstChild("RemoteEvents")
                        if remotes then
                            local ammoRemote = remotes:FindFirstChild("ChangeMagAndAmmo")
                            if ammoRemote then ammoRemote:Destroy() end
                        end
                    end)
                end
            end)
        else
            if Connections["InfiniteAmmo"] then
                Connections["InfiniteAmmo"]:Disconnect()
                Connections["InfiniteAmmo"] = nil
            end
        end
    end
})

-- Rapid Fire
GunModsSection:AddToggle({
    ["Name"] = "| Rapid Fire",
    ["Callback"] = function(Value)
        Settings.RapidFireEnabled = Value
        
        if Value then
            Connections["RapidFire"] = RunService.Heartbeat:Connect(function()
                if Settings.RapidFireEnabled and LocalCharacter then
                    for _, tool in pairs(LocalCharacter:GetChildren()) do
                        if tool:IsA("Tool") then
                            for _, v in pairs(tool:GetDescendants()) do
                                if v:IsA("NumberValue") then
                                    local name = string.lower(v.Name)
                                    if string.find(name, "fire") or string.find(name, "rate") or string.find(name, "cooldown") or string.find(name, "delay") then
                                        v.Value = Settings.RapidFireRate
                                    end
                                end
                            end
                        end
                    end
                end
            end)
        else
            if Connections["RapidFire"] then
                Connections["RapidFire"]:Disconnect()
                Connections["RapidFire"] = nil
            end
        end
    end
})

-- Rapid Fire Rate Slider
GunModsSection:AddSlider({
    ["Min"] = 0.01,
    ["Max"] = 1,
    ["Name"] = "Firerate Settings",
    ["Value"] = 0.05,
    ["Decimals"] = 2,
    ["Flag"] = "FirerateSlider",
    ["Callback"] = function(Value)
        Settings.RapidFireRate = Value
    end
})

-- Quick Reload
GunModsSection:AddToggle({
    ["Name"] = "| Quick Reload",
    ["Callback"] = function(Value)
        Settings.QuickReloadEnabled = Value
        
        if Value then
            Connections["QuickReload"] = RunService.Heartbeat:Connect(function()
                if Settings.QuickReloadEnabled and LocalCharacter then
                    for _, tool in pairs(LocalCharacter:GetChildren()) do
                        if tool:IsA("Tool") then
                            for _, v in pairs(tool:GetDescendants()) do
                                if v:IsA("NumberValue") then
                                    local name = string.lower(v.Name)
                                    if string.find(name, "reload") then
                                        v.Value = 0.1
                                    end
                                end
                            end
                        end
                    end
                end
            end)
        else
            if Connections["QuickReload"] then
                Connections["QuickReload"]:Disconnect()
                Connections["QuickReload"] = nil
            end
        end
    end
})

-- No Recoil
GunModsSection:AddToggle({
    ["Name"] = "| 0 Recoil",
    ["Callback"] = function(Value)
        Settings.NoRecoilEnabled = Value
        
        if Value then
            Connections["NoRecoil"] = RunService.Heartbeat:Connect(function()
                if Settings.NoRecoilEnabled and LocalCharacter then
                    for _, tool in pairs(LocalCharacter:GetChildren()) do
                        if tool:IsA("Tool") then
                            for _, v in pairs(tool:GetDescendants()) do
                                if v:IsA("NumberValue") then
                                    local name = string.lower(v.Name)
                                    if string.find(name, "recoil") or string.find(name, "kick") or string.find(name, "spread") then
                                        v.Value = 0
                                    end
                                end
                            end
                        end
                    end
                end
            end)
        else
            if Connections["NoRecoil"] then
                Connections["NoRecoil"]:Disconnect()
                Connections["NoRecoil"] = nil
            end
        end
    end
})

-- No Spread
GunModsSection:AddToggle({
    ["Name"] = "| No Spread",
    ["Callback"] = function(Value)
        Settings.NoSpreadEnabled = Value
        
        if Value then
            Connections["NoSpread"] = RunService.Heartbeat:Connect(function()
                if Settings.NoSpreadEnabled and LocalCharacter then
                    for _, tool in pairs(LocalCharacter:GetChildren()) do
                        if tool:IsA("Tool") then
                            for _, v in pairs(tool:GetDescendants()) do
                                if v:IsA("NumberValue") then
                                    local name = string.lower(v.Name)
                                    if string.find(name, "spread") or string.find(name, "accuracy") or string.find(name, "bloom") then
                                        v.Value = 0
                                    end
                                end
                            end
                        end
                    end
                end
            end)
        else
            if Connections["NoSpread"] then
                Connections["NoSpread"]:Disconnect()
                Connections["NoSpread"] = nil
            end
        end
    end
})

-- No Jam
GunModsSection:AddToggle({
    ["Name"] = "| No Jam",
    ["Callback"] = function(Value)
        if Value then
            Connections["NoJam"] = RunService.Heartbeat:Connect(function()
                if LocalCharacter then
                    for _, tool in pairs(LocalCharacter:GetChildren()) do
                        if tool:IsA("Tool") then
                            for _, v in pairs(tool:GetDescendants()) do
                                local name = string.lower(v.Name)
                                if string.find(name, "jam") then
                                    if v:IsA("BoolValue") then v.Value = false end
                                    if v:IsA("NumberValue") then v.Value = 0 end
                                end
                            end
                        end
                    end
                end
            end)
        else
            if Connections["NoJam"] then
                Connections["NoJam"]:Disconnect()
                Connections["NoJam"] = nil
            end
        end
    end
})

-- Infinite Range
GunModsSection:AddToggle({
    ["Name"] = "| Infinite Range",
    ["Callback"] = function(Value)
        Settings.InfiniteRangeEnabled = Value
        
        if Value then
            Connections["InfiniteRange"] = RunService.Heartbeat:Connect(function()
                if Settings.InfiniteRangeEnabled and LocalCharacter then
                    for _, tool in pairs(LocalCharacter:GetChildren()) do
                        if tool:IsA("Tool") then
                            for _, v in pairs(tool:GetDescendants()) do
                                if v:IsA("NumberValue") then
                                    local name = string.lower(v.Name)
                                    if string.find(name, "range") or string.find(name, "distance") or string.find(name, "maxdist") then
                                        v.Value = 99999
                                    end
                                end
                            end
                        end
                    end
                end
            end)
        else
            if Connections["InfiniteRange"] then
                Connections["InfiniteRange"]:Disconnect()
                Connections["InfiniteRange"] = nil
            end
        end
    end
})

-- Auto Shoot
GunModsSection:AddToggle({
    ["Name"] = "| Auto Shoot",
    ["Callback"] = function(Value)
        if Value then
            Connections["AutoShoot"] = RunService.Heartbeat:Connect(function()
                if LocalCharacter then
                    for _, tool in pairs(LocalCharacter:GetChildren()) do
                        if tool:IsA("Tool") then
                            pcall(function()
                                tool:Activate()
                            end)
                        end
                    end
                end
            end)
        else
            if Connections["AutoShoot"] then
                Connections["AutoShoot"]:Disconnect()
                Connections["AutoShoot"] = nil
            end
        end
    end
})

-- Music on Hit
local MusicOnHitEnabled = false
local MusicOnHitId = ""

GunModsSection:AddToggle({
    ["Name"] = "| Music on Hit",
    ["Callback"] = function(Value)
        MusicOnHitEnabled = Value
    end
})

GunModsSection:AddTextbox({
    ["Name"] = "Music ID",
    ["Value"] = "",
    ["Callback"] = function(Value)
        MusicOnHitId = "rbxassetid://" .. Value
    end
})

-- Shotgun Mode
local ShotgunModeEnabled = false
local ShotgunPellets = 10

GunModsSection:AddToggle({
    ["Name"] = "| Shotgun Mode",
    ["Callback"] = function(Value)
        ShotgunModeEnabled = Value
        
        if Value then
            Connections["ShotgunMode"] = RunService.Heartbeat:Connect(function()
                if ShotgunModeEnabled and LocalCharacter then
                    for _, tool in pairs(LocalCharacter:GetChildren()) do
                        if tool:IsA("Tool") then
                            for _, v in pairs(tool:GetDescendants()) do
                                if v:IsA("NumberValue") then
                                    local name = string.lower(v.Name)
                                    if string.find(name, "pellet") or string.find(name, "bullet") or string.find(name, "shot") then
                                        v.Value = ShotgunPellets
                                    end
                                end
                            end
                        end
                    end
                end
            end)
        else
            if Connections["ShotgunMode"] then
                Connections["ShotgunMode"]:Disconnect()
                Connections["ShotgunMode"] = nil
            end
        end
    end
})

GunModsSection:AddSlider({
    ["Min"] = 2,
    ["Max"] = 50,
    ["Name"] = "Pellet Count",
    ["Value"] = 10,
    ["Decimals"] = 0,
    ["Callback"] = function(Value)
        ShotgunPellets = Value
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 11: MAIN TAB - SPAWN LOCATIONS SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local SpawnSection = MainTab:CreateSection({
    ["Name"] = "|Spawn To Locations|",
    ["Side"] = "Right"
})

-- Location CFrames
local LocationCFrames = {
    ["Spawn"] = CFrame.new(0, 5, 0),
    ["Gun Store"] = CFrame.new(100, 5, 100),
    ["Bank"] = CFrame.new(-100, 5, 100),
    ["Hospital"] = CFrame.new(100, 5, -100),
    ["Police Station"] = CFrame.new(-100, 5, -100),
    ["Gas Station"] = CFrame.new(200, 5, 0),
    ["Apartments"] = CFrame.new(0, 5, 200),
    ["Corner Store"] = CFrame.new(-200, 5, 0),
    ["Warehouse"] = CFrame.new(0, 5, -200),
    ["Alley"] = CFrame.new(150, 5, 150),
    ["Rooftop"] = CFrame.new(-150, 50, 150),
    ["Parking Lot"] = CFrame.new(150, 5, -150),
    ["Basketball Court"] = CFrame.new(-150, 5, -150),
    ["Subway"] = CFrame.new(0, -20, 0),
    ["Bridge"] = CFrame.new(300, 30, 0),
    ["ATM 1"] = CFrame.new(50, 5, 50),
    ["ATM 2"] = CFrame.new(-50, 5, 50),
    ["ATM 3"] = CFrame.new(50, 5, -50)
}

-- Find locations dynamically
local function findGameLocations()
    local locations = {}
    
    for _, part in pairs(Workspace:GetDescendants()) do
        if part:IsA("BasePart") then
            local name = string.lower(part.Name)
            
            if string.find(name, "spawn") then
                locations["Spawn"] = part.CFrame + Vector3.new(0, 5, 0)
            elseif string.find(name, "gun") and string.find(name, "store") then
                locations["Gun Store"] = part.CFrame + Vector3.new(0, 5, 0)
            elseif string.find(name, "bank") then
                locations["Bank"] = part.CFrame + Vector3.new(0, 5, 0)
            elseif string.find(name, "hospital") then
                locations["Hospital"] = part.CFrame + Vector3.new(0, 5, 0)
            elseif string.find(name, "police") then
                locations["Police Station"] = part.CFrame + Vector3.new(0, 5, 0)
            elseif string.find(name, "gas") then
                locations["Gas Station"] = part.CFrame + Vector3.new(0, 5, 0)
            elseif string.find(name, "apartment") then
                locations["Apartments"] = part.CFrame + Vector3.new(0, 5, 0)
            elseif string.find(name, "atm") then
                local atmCount = 0
                for k, _ in pairs(locations) do
                    if string.find(k, "ATM") then atmCount = atmCount + 1 end
                end
                locations["ATM " .. (atmCount + 1)] = part.CFrame + Vector3.new(0, 5, 0)
            end
        end
    end
    
    -- Merge with defaults
    for name, cf in pairs(LocationCFrames) do
        if not locations[name] then
            locations[name] = cf
        end
    end
    
    return locations
end

-- Get location names
local function getLocationNames()
    local names = {}
    for name, _ in pairs(LocationCFrames) do
        table.insert(names, name)
    end
    table.sort(names)
    return names
end

local SelectedSpawnLocation = "Spawn"

-- Location Dropdown
SpawnSection:AddDropdown({
    ["Name"] = "Spawn/Tween Locations",
    ["List"] = getLocationNames(),
    ["Callback"] = function(Value)
        SelectedSpawnLocation = Value
    end
})

-- Set Spawn Point Toggle
local SavedSpawnPoint = nil
SpawnSection:AddToggle({
    ["Name"] = "| Set Spawn Point",
    ["Callback"] = function(Value)
        if Value then
            local hrp = getHRP()
            if hrp then
                SavedSpawnPoint = hrp.CFrame
                sendNotification("Spawn Point", "Spawn point saved!")
            end
        else
            SavedSpawnPoint = nil
        end
    end
})

-- Teleport Now Button
SpawnSection:AddButton({
    ["Name"] = "| Teleport Now",
    ["Callback"] = function()
        local hrp = getHRP()
        if hrp then
            local locations = findGameLocations()
            local targetCF = locations[SelectedSpawnLocation] or LocationCFrames[SelectedSpawnLocation]
            
            if targetCF then
                hrp.CFrame = targetCF
                sendNotification("Teleported", "Teleported to " .. SelectedSpawnLocation)
            end
        end
    end
})

-- Tween to Location Button
SpawnSection:AddButton({
    ["Name"] = "| Tween to Location",
    ["Callback"] = function()
        local hrp = getHRP()
        if hrp then
            local locations = findGameLocations()
            local targetCF = locations[SelectedSpawnLocation] or LocationCFrames[SelectedSpawnLocation]
            
            if targetCF then
                local distance = (hrp.Position - targetCF.Position).Magnitude
                local duration = distance / 100 -- 100 studs per second
                
                tweenTo(targetCF.Position, duration)
                sendNotification("Tweening", "Tweening to " .. SelectedSpawnLocation)
            end
        end
    end
})

-- Teleport to Saved Spawn
SpawnSection:AddButton({
    ["Name"] = "| TP to Saved Spawn",
    ["Callback"] = function()
        if SavedSpawnPoint then
            local hrp = getHRP()
            if hrp then
                hrp.CFrame = SavedSpawnPoint
                sendNotification("Teleported", "Teleported to saved spawn point!")
            end
        else
            sendNotification("Error", "No spawn point saved!")
        end
    end
})

-- Refresh Locations
SpawnSection:AddButton({
    ["Name"] = "| Refresh Locations",
    ["Callback"] = function()
        local locations = findGameLocations()
        local count = 0
        for _, _ in pairs(locations) do count = count + 1 end
        sendNotification("Locations", "Found " .. count .. " locations")
    end
})


--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 12: MAIN TAB - SERVER SETTINGS SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local ServerSettingsSection = MainTab:CreateSection({
    ["Name"] = "Server Settings",
    ["Side"] = "Right"
})

-- Mod Detection
ServerSettingsSection:AddButton({
    ["Flag"] = "InstantSection_ModDetection",
    ["Name"] = "Mod Detection",
    ["Callback"] = function()
        local mods = {}
        for _, player in pairs(Players:GetPlayers()) do
            local name = string.lower(player.Name)
            local displayName = string.lower(player.DisplayName or "")
            
            if string.find(name, "mod") or string.find(name, "admin") or string.find(name, "staff") or
               string.find(displayName, "mod") or string.find(displayName, "admin") or string.find(displayName, "staff") then
                table.insert(mods, player.Name)
            end
        end
        
        if #mods > 0 then
            print("=== POTENTIAL MODS DETECTED ===")
            for _, name in pairs(mods) do
                print("- " .. name)
            end
            print("===============================")
            sendNotification("Mod Detection", "Found " .. #mods .. " potential mods!")
        else
            sendNotification("Mod Detection", "No mods detected!")
        end
    end
})

-- Server Hop (GITHUB)
ServerSettingsSection:AddButton({
    ["Name"] = "Server Hop",
    ["Callback"] = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Morples/Server-hop/refs/heads/main/Script", true))()
    end
})

-- Rejoin Server
ServerSettingsSection:AddButton({
    ["Name"] = "Rejoin Server",
    ["Callback"] = function()
        sendNotification("Rejoining", "Rejoining server...")
        task.wait(1)
        TeleportService:Teleport(GamePlaceId, LocalPlayer)
    end
})

-- Join Lowest Server
ServerSettingsSection:AddButton({
    ["Name"] = "Join Lowest Server",
    ["Callback"] = function()
        pcall(function()
            local servers = HttpService:JSONDecode(
                game:HttpGet("https://games.roblox.com/v1/games/" .. GamePlaceId .. "/servers/Public?sortOrder=Asc&limit=100")
            )
            
            if servers and servers.data and servers.data[1] then
                local targetServer = servers.data[1]
                sendNotification("Joining", "Joining server with " .. targetServer.playing .. " players...")
                TeleportService:TeleportToPlaceInstance(GamePlaceId, targetServer.id, LocalPlayer)
            else
                sendNotification("Error", "No servers found!")
            end
        end)
    end
})

-- Anti AFK (PASTEBIN)
ServerSettingsSection:AddButton({
    ["Name"] = "Anti AFK",
    ["Callback"] = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/DtwLVRdP"))()
        sendNotification("Anti AFK", "Anti AFK enabled!")
    end
})

-- Suicide
ServerSettingsSection:AddButton({
    ["Name"] = "Suicide",
    ["Callback"] = function()
        local hum = getHumanoid()
        if hum then
            hum.Health = 0
        end
    end
})

-- HideName (PASTEBIN)
ServerSettingsSection:AddButton({
    ["StartingState"] = false,
    ["Name"] = "HideName",
    ["Description"] = "This Hides Player Names.",
    ["Callback"] = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/iPcPNt23"))()
        sendNotification("Hide Name", "Name hidden!")
    end
})

-- Enable Reset Button (PASTEBIN)
ServerSettingsSection:AddButton({
    ["Name"] = "Enable Reset Button",
    ["Flag"] = "resetbutton",
    ["Value"] = false,
    ["Callback"] = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/pvNpdimg"))()
        sendNotification("Reset Button", "Reset button enabled!")
    end
})

-- Low GFX (PASTEBIN)
ServerSettingsSection:AddButton({
    ["StartingState"] = false,
    ["Name"] = "Low Gfx",
    ["Description"] = "This Reduces Graphics for Better Performance.",
    ["Callback"] = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/SS4E3tDQ"))()
        sendNotification("Low GFX", "Graphics reduced!")
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 13: AIMBOT TAB - MAIN AIMBOT SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local AimbotSection = AimbotTab:CreateSection({
    ["Name"] = "Aimbot",
    ["Side"] = "Left"
})

-- Create FOV Circle
FOVCircle = Drawing.new("Circle")
FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
FOVCircle.Radius = Settings.AimbotFOV
FOVCircle.Filled = false
FOVCircle.Color = Color3.fromRGB(255, 255, 255)
FOVCircle.Visible = false
FOVCircle.Transparency = 0.7
FOVCircle.NumSides = 64
FOVCircle.Thickness = 1

-- Aimbot Toggle
AimbotSection:AddToggle({
    ["Name"] = "| Aimbot",
    ["Description"] = "Locks Onto Other Players' Heads.",
    ["Callback"] = function(Value)
        Settings.AimbotEnabled = Value
    end
})

-- FOV Circle Toggle
AimbotSection:AddToggle({
    ["Name"] = "| FOV Circle",
    ["Description"] = "Toggle Visibility of FOV Circle.",
    ["Callback"] = function(Value)
        Settings.FOVCircleEnabled = Value
        FOVCircle.Visible = Value
    end
})

-- FOV Radius Slider
AimbotSection:AddSlider({
    ["Min"] = 50,
    ["Max"] = 500,
    ["Name"] = "FOV Radius",
    ["Default"] = 150,
    ["Callback"] = function(Value)
        Settings.AimbotFOV = Value
        FOVCircle.Radius = Value
    end
})

-- Smoothness Slider
AimbotSection:AddSlider({
    ["Min"] = 0,
    ["Max"] = 100,
    ["Name"] = "Smoothness",
    ["Default"] = 50,
    ["Callback"] = function(Value)
        Settings.AimbotSmoothness = Value / 100
    end
})

-- FOV Thickness Slider
AimbotSection:AddSlider({
    ["Min"] = 1,
    ["Max"] = 5,
    ["Name"] = "FOV Thickness",
    ["Default"] = 1,
    ["Callback"] = function(Value)
        Settings.FOVCircleThickness = Value
        FOVCircle.Thickness = Value
    end
})

-- Body Part Dropdown
AimbotSection:AddDropdown({
    ["Name"] = "Body Parts",
    ["List"] = {"Head", "UpperTorso", "LowerTorso", "HumanoidRootPart", "LeftLeg", "RightLeg", "LeftArm", "RightArm"},
    ["Callback"] = function(Value)
        Settings.AimbotPart = Value
    end
})

-- Team Check Toggle
AimbotSection:AddToggle({
    ["Name"] = "| Team Check",
    ["Callback"] = function(Value)
        Settings.AimbotTeamCheck = Value
    end
})

-- Visibility Check Toggle
AimbotSection:AddToggle({
    ["Name"] = "| Visibility Check",
    ["Callback"] = function(Value)
        Settings.AimbotVisibleCheck = Value
    end
})

-- Prediction Slider
AimbotSection:AddSlider({
    ["Min"] = 0,
    ["Max"] = 1,
    ["Name"] = "Prediction",
    ["Default"] = 0,
    ["Decimals"] = 2,
    ["Callback"] = function(Value)
        Settings.AimbotPrediction = Value
    end
})

-- Aim Lock Toggle
AimbotSection:AddToggle({
    ["Name"] = "| Aim Lock",
    ["Description"] = "Lock onto a single target until out of FOV.",
    ["Callback"] = function(Value)
        Settings.AimbotLocked = Value
        if not Value then
            Settings.AimbotLockedTarget = nil
        end
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 14: AIMBOT TAB - MOBILE AIMBOT SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local MobileAimbotSection = AimbotTab:CreateSection({
    ["Name"] = "Mobile Aimbot",
    ["Side"] = "Left"
})

-- Mobile Aimbot Toggle
local MobileAimbotEnabled = false
MobileAimbotSection:AddToggle({
    ["Name"] = "| Mobile Aimbot",
    ["Callback"] = function(Value)
        MobileAimbotEnabled = Value
    end
})

-- Touch Sensitivity
MobileAimbotSection:AddSlider({
    ["Min"] = 0.1,
    ["Max"] = 2,
    ["Name"] = "Touch Sensitivity",
    ["Default"] = 1,
    ["Decimals"] = 1,
    ["Callback"] = function(Value)
        -- Mobile sensitivity
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 15: AIMBOT TAB - SILENT AIM SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local SilentAimSection = AimbotTab:CreateSection({
    ["Name"] = "Silent Aim",
    ["Side"] = "Right"
})

-- Silent Aim & Wall Bang (PASTEBIN)
SilentAimSection:AddButton({
    ["Value"] = false,
    ["Name"] = "Silent Aim & Wall Bang",
    ["Flag"] = "Toggle",
    ["Callback"] = function()
        local code = game:HttpGet("https://pastebin.com/raw/5JgzHnDU", true)
        print(code)
        loadstring(code)()
        sendNotification("Silent Aim", "Silent Aim & Wall Bang loaded!")
    end
})

-- Wall Bang Toggle
local WallBangEnabled = false
SilentAimSection:AddToggle({
    ["Name"] = "| Wall Bang",
    ["Description"] = "Shoot through walls.",
    ["Callback"] = function(Value)
        WallBangEnabled = Value
    end
})

-- Trigger Bot Toggle
local TriggerBotEnabled = false
local TriggerBotDelay = 0.1

SilentAimSection:AddToggle({
    ["Name"] = "| Trigger Bot",
    ["Description"] = "Auto shoots when aiming at target.",
    ["Callback"] = function(Value)
        TriggerBotEnabled = Value
        
        if Value then
            Connections["TriggerBot"] = RunService.RenderStepped:Connect(function()
                if TriggerBotEnabled then
                    local target = getClosestPlayerToMouse()
                    if target then
                        task.wait(TriggerBotDelay)
                        -- Simulate click
                        local tool = getEquippedTool()
                        if tool then
                            pcall(function() tool:Activate() end)
                        end
                    end
                end
            end)
        else
            if Connections["TriggerBot"] then
                Connections["TriggerBot"]:Disconnect()
                Connections["TriggerBot"] = nil
            end
        end
    end
})

-- Trigger Bot Delay Slider
SilentAimSection:AddSlider({
    ["Min"] = 0,
    ["Max"] = 1,
    ["Name"] = "Trigger Bot Delay",
    ["Default"] = 0.1,
    ["Decimals"] = 2,
    ["Callback"] = function(Value)
        TriggerBotDelay = Value
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 16: AIMBOT LOGIC (RENDERSTEPPED)
═══════════════════════════════════════════════════════════════════════════ ]]--

-- Aimbot Input Handler
local AimbotHolding = false

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        AimbotHolding = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        AimbotHolding = false
        if not Settings.AimbotLocked then
            Settings.AimbotLockedTarget = nil
        end
    end
end)

-- Aimbot RenderStepped Loop
Connections["AimbotLoop"] = RunService.RenderStepped:Connect(function()
    -- Update FOV Circle position
    local mousePos = UserInputService:GetMouseLocation()
    FOVCircle.Position = mousePos
    
    -- Aimbot Logic
    if Settings.AimbotEnabled and AimbotHolding then
        local target = nil
        
        -- Check if we have a locked target
        if Settings.AimbotLocked and Settings.AimbotLockedTarget then
            -- Verify locked target is still valid
            if Settings.AimbotLockedTarget.Character and 
               Settings.AimbotLockedTarget.Character:FindFirstChild(Settings.AimbotPart) then
                target = Settings.AimbotLockedTarget
            else
                Settings.AimbotLockedTarget = nil
            end
        end
        
        -- Find new target if needed
        if not target then
            target = getClosestPlayerToMouse()
            if Settings.AimbotLocked then
                Settings.AimbotLockedTarget = target
            end
        end
        
        -- Aim at target
        if target and target.Character then
            local targetPart = target.Character:FindFirstChild(Settings.AimbotPart) or target.Character:FindFirstChild("Head")
            
            if targetPart then
                local targetPos = targetPart.Position
                
                -- Apply prediction
                if Settings.AimbotPrediction > 0 then
                    local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
                    if targetHRP then
                        targetPos = targetPos + (targetHRP.Velocity * Settings.AimbotPrediction)
                    end
                end
                
                local screenPos = Camera:WorldToScreenPoint(targetPos)
                local currentPos = UserInputService:GetMouseLocation()
                
                -- Calculate smoothed position
                local smooth = 1 - Settings.AimbotSmoothness
                local newPos = currentPos:Lerp(Vector2.new(screenPos.X, screenPos.Y), smooth)
                
                -- Move mouse
                if mousemoverel then
                    mousemoverel((newPos.X - currentPos.X), (newPos.Y - currentPos.Y))
                end
            end
        end
    end
end)


--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 17: VISUALS TAB - ESP SECTION (PASTEBINS)
═══════════════════════════════════════════════════════════════════════════ ]]--

local EspSection = VisualsTab:CreateSection({
    ["Name"] = "ESPs",
    ["Side"] = "Left"
})

-- Boxes ESP (PASTEBIN)
EspSection:AddToggle({
    ["StartingState"] = false,
    ["Name"] = "| Boxes",
    ["Description"] = "This Adds Boxes Above People's Heads.",
    ["Callback"] = function(Value)
        if Value then
            loadstring(game:HttpGet("https://pastebin.com/raw/i9EFDTBn"))()
        end
    end
})

-- Name ESP (PASTEBIN)
EspSection:AddToggle({
    ["StartingState"] = false,
    ["Name"] = "| Name",
    ["Description"] = "This Adds People's Names Above Their Heads.",
    ["Callback"] = function(Value)
        if Value then
            loadstring(game:HttpGet("https://pastebin.com/raw/eaXVeBdR"))()
        end
    end
})

-- Health Bar ESP (PASTEBIN)
EspSection:AddToggle({
    ["StartingState"] = false,
    ["Name"] = "| Health Bar",
    ["Description"] = "This Adds People's Health Bars.",
    ["Callback"] = function(Value)
        if Value then
            loadstring(game:HttpGet("https://pastebin.com/raw/RZ7kbGD6"))()
        end
    end
})

-- Distance ESP (PASTEBIN)
EspSection:AddToggle({
    ["StartingState"] = false,
    ["Name"] = "| Distance ESP",
    ["Callback"] = function(Value)
        if Value then
            loadstring(game:HttpGet("https://pastebin.com/raw/nRmXUbTA"))()
        end
    end
})

-- Skeleton ESP (PASTEBIN)
EspSection:AddToggle({
    ["StartingState"] = false,
    ["Name"] = "| Skeleton",
    ["Callback"] = function(Value)
        if Value then
            loadstring(game:HttpGet("https://pastebin.com/raw/pZaywk6y"))()
        end
    end
})

-- Arrows ESP (PASTEBIN)
EspSection:AddToggle({
    ["StartingState"] = false,
    ["Name"] = "| Arrows",
    ["Callback"] = function(Value)
        if Value then
            loadstring(game:HttpGet("https://pastebin.com/raw/ZJpnUcNX"))()
        end
    end
})

-- Inventory ESP (PASTEBIN)
EspSection:AddToggle({
    ["StartingState"] = false,
    ["Name"] = "| Inventory ESP",
    ["Callback"] = function(Value)
        if Value then
            loadstring(game:HttpGet("https://pastebin.com/raw/7HTXKCAY"))()
        end
    end
})

-- Radar (PASTEBIN)
EspSection:AddToggle({
    ["StartingState"] = false,
    ["Name"] = "| Radar",
    ["Callback"] = function(Value)
        if Value then
            loadstring(game:HttpGet("https://pastebin.com/raw/cGRig6ey"))()
        end
    end
})

-- FullBright (PASTEBIN)
EspSection:AddToggle({
    ["StartingState"] = false,
    ["Name"] = "| FullBright",
    ["Callback"] = function(Value)
        if Value then
            loadstring(game:HttpGet("https://pastebin.com/raw/dvMVMTGA"))()
        end
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 18: VISUALS TAB - CUSTOM ESP SECTION (DRAWING LIBRARY)
═══════════════════════════════════════════════════════════════════════════ ]]--

local CustomESPSection = VisualsTab:CreateSection({
    ["Name"] = "|Custom ESP (Drawing)|",
    ["Side"] = "Left"
})

-- Create ESP for player function
local function createESPForPlayer(player)
    if player == LocalPlayer then return end
    
    ESPObjects[player] = {
        Box = Drawing.new("Square"),
        BoxOutline = Drawing.new("Square"),
        Name = Drawing.new("Text"),
        Distance = Drawing.new("Text"),
        Health = Drawing.new("Line"),
        HealthBG = Drawing.new("Line"),
        HealthOutline = Drawing.new("Line"),
        Tracer = Drawing.new("Line"),
        HeadDot = Drawing.new("Circle"),
        Weapon = Drawing.new("Text"),
        Skeleton = {
            Head_UpperTorso = Drawing.new("Line"),
            UpperTorso_LowerTorso = Drawing.new("Line"),
            UpperTorso_LeftUpperArm = Drawing.new("Line"),
            LeftUpperArm_LeftLowerArm = Drawing.new("Line"),
            LeftLowerArm_LeftHand = Drawing.new("Line"),
            UpperTorso_RightUpperArm = Drawing.new("Line"),
            RightUpperArm_RightLowerArm = Drawing.new("Line"),
            RightLowerArm_RightHand = Drawing.new("Line"),
            LowerTorso_LeftUpperLeg = Drawing.new("Line"),
            LeftUpperLeg_LeftLowerLeg = Drawing.new("Line"),
            LeftLowerLeg_LeftFoot = Drawing.new("Line"),
            LowerTorso_RightUpperLeg = Drawing.new("Line"),
            RightUpperLeg_RightLowerLeg = Drawing.new("Line"),
            RightLowerLeg_RightFoot = Drawing.new("Line")
        }
    }
    
    local esp = ESPObjects[player]
    
    -- Box Setup
    esp.Box.Visible = false
    esp.Box.Color = Settings.ESPBoxColor
    esp.Box.Thickness = 1
    esp.Box.Filled = false
    esp.Box.Transparency = 1
    
    esp.BoxOutline.Visible = false
    esp.BoxOutline.Color = Color3.new(0, 0, 0)
    esp.BoxOutline.Thickness = 3
    esp.BoxOutline.Filled = false
    esp.BoxOutline.Transparency = 1
    
    -- Name Setup
    esp.Name.Visible = false
    esp.Name.Color = Settings.ESPNameColor
    esp.Name.Size = 14
    esp.Name.Center = true
    esp.Name.Outline = true
    esp.Name.OutlineColor = Color3.new(0, 0, 0)
    esp.Name.Font = Drawing.Fonts.UI
    
    -- Distance Setup
    esp.Distance.Visible = false
    esp.Distance.Color = Color3.new(1, 1, 1)
    esp.Distance.Size = 12
    esp.Distance.Center = true
    esp.Distance.Outline = true
    esp.Distance.OutlineColor = Color3.new(0, 0, 0)
    esp.Distance.Font = Drawing.Fonts.UI
    
    -- Health Bar Setup
    esp.Health.Visible = false
    esp.Health.Color = Color3.new(0, 1, 0)
    esp.Health.Thickness = 2
    
    esp.HealthBG.Visible = false
    esp.HealthBG.Color = Color3.fromRGB(50, 50, 50)
    esp.HealthBG.Thickness = 4
    
    esp.HealthOutline.Visible = false
    esp.HealthOutline.Color = Color3.new(0, 0, 0)
    esp.HealthOutline.Thickness = 6
    
    -- Tracer Setup
    esp.Tracer.Visible = false
    esp.Tracer.Color = Settings.ESPTracerColor
    esp.Tracer.Thickness = 1
    
    -- Head Dot Setup
    esp.HeadDot.Visible = false
    esp.HeadDot.Color = Color3.fromRGB(255, 0, 0)
    esp.HeadDot.Thickness = 1
    esp.HeadDot.NumSides = 32
    esp.HeadDot.Radius = 5
    esp.HeadDot.Filled = true
    
    -- Weapon Text Setup
    esp.Weapon.Visible = false
    esp.Weapon.Color = Color3.fromRGB(255, 255, 0)
    esp.Weapon.Size = 12
    esp.Weapon.Center = true
    esp.Weapon.Outline = true
    esp.Weapon.OutlineColor = Color3.new(0, 0, 0)
    esp.Weapon.Font = Drawing.Fonts.UI
    
    -- Skeleton Setup
    for _, line in pairs(esp.Skeleton) do
        line.Visible = false
        line.Color = Settings.ESPSkeletonColor
        line.Thickness = 1
        line.Transparency = 1
    end
end

-- Remove ESP for player function
local function removeESPForPlayer(player)
    if ESPObjects[player] then
        local esp = ESPObjects[player]
        
        pcall(function() esp.Box:Remove() end)
        pcall(function() esp.BoxOutline:Remove() end)
        pcall(function() esp.Name:Remove() end)
        pcall(function() esp.Distance:Remove() end)
        pcall(function() esp.Health:Remove() end)
        pcall(function() esp.HealthBG:Remove() end)
        pcall(function() esp.HealthOutline:Remove() end)
        pcall(function() esp.Tracer:Remove() end)
        pcall(function() esp.HeadDot:Remove() end)
        pcall(function() esp.Weapon:Remove() end)
        
        for _, line in pairs(esp.Skeleton) do
            pcall(function() line:Remove() end)
        end
        
        ESPObjects[player] = nil
    end
end

-- Update ESP Function
local function updateCustomESP()
    for player, esp in pairs(ESPObjects) do
        if not player or not player.Parent or not player.Character then
            removeESPForPlayer(player)
            continue
        end
        
        local char = player.Character
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local head = char:FindFirstChild("Head")
        local hum = char:FindFirstChildOfClass("Humanoid")
        
        if not hrp or not head or not hum then
            esp.Box.Visible = false
            esp.BoxOutline.Visible = false
            esp.Name.Visible = false
            esp.Distance.Visible = false
            esp.Health.Visible = false
            esp.HealthBG.Visible = false
            esp.HealthOutline.Visible = false
            esp.Tracer.Visible = false
            esp.HeadDot.Visible = false
            esp.Weapon.Visible = false
            for _, line in pairs(esp.Skeleton) do
                line.Visible = false
            end
            continue
        end
        
        local screenPos, onScreen = Camera:WorldToScreenPoint(hrp.Position)
        
        if onScreen then
            local myHRP = getHRP()
            local dist = myHRP and (hrp.Position - myHRP.Position).Magnitude or 0
            local scaleFactor = 1 / (screenPos.Z * math.tan(math.rad(Camera.FieldOfView / 2)) * 2) * 1000
            local boxHeight = scaleFactor * 4.5
            local boxWidth = boxHeight * 0.5
            
            -- Box ESP
            if Settings.ESPBoxEnabled then
                esp.BoxOutline.Visible = true
                esp.BoxOutline.Position = Vector2.new(screenPos.X - boxWidth/2 - 1, screenPos.Y - boxHeight/2 - 1)
                esp.BoxOutline.Size = Vector2.new(boxWidth + 2, boxHeight + 2)
                
                esp.Box.Visible = true
                esp.Box.Position = Vector2.new(screenPos.X - boxWidth/2, screenPos.Y - boxHeight/2)
                esp.Box.Size = Vector2.new(boxWidth, boxHeight)
                esp.Box.Color = Settings.ESPBoxColor
            else
                esp.Box.Visible = false
                esp.BoxOutline.Visible = false
            end
            
            -- Name ESP
            if Settings.ESPNameEnabled then
                esp.Name.Visible = true
                esp.Name.Position = Vector2.new(screenPos.X, screenPos.Y - boxHeight/2 - 18)
                esp.Name.Text = player.DisplayName or player.Name
                esp.Name.Color = Settings.ESPNameColor
            else
                esp.Name.Visible = false
            end
            
            -- Distance ESP
            if Settings.ESPDistanceEnabled then
                esp.Distance.Visible = true
                esp.Distance.Position = Vector2.new(screenPos.X, screenPos.Y + boxHeight/2 + 5)
                esp.Distance.Text = string.format("[%dm]", math.floor(dist))
            else
                esp.Distance.Visible = false
            end
            
            -- Health ESP
            if Settings.ESPHealthEnabled then
                local healthPercent = math.clamp(hum.Health / hum.MaxHealth, 0, 1)
                
                local barX = screenPos.X - boxWidth/2 - 6
                local barTop = screenPos.Y - boxHeight/2
                local barBottom = screenPos.Y + boxHeight/2
                
                esp.HealthOutline.Visible = true
                esp.HealthOutline.From = Vector2.new(barX, barTop - 1)
                esp.HealthOutline.To = Vector2.new(barX, barBottom + 1)
                
                esp.HealthBG.Visible = true
                esp.HealthBG.From = Vector2.new(barX, barTop)
                esp.HealthBG.To = Vector2.new(barX, barBottom)
                
                esp.Health.Visible = true
                esp.Health.From = Vector2.new(barX, barBottom)
                esp.Health.To = Vector2.new(barX, barBottom - (boxHeight * healthPercent))
                esp.Health.Color = Color3.fromHSV(healthPercent * 0.3, 1, 1)
            else
                esp.Health.Visible = false
                esp.HealthBG.Visible = false
                esp.HealthOutline.Visible = false
            end
            
            -- Tracer ESP
            if Settings.ESPTracerEnabled then
                esp.Tracer.Visible = true
                
                local tracerFrom
                if Settings.ESPTracerOrigin == "Top" then
                    tracerFrom = Vector2.new(Camera.ViewportSize.X / 2, 0)
                elseif Settings.ESPTracerOrigin == "Center" then
                    tracerFrom = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                elseif Settings.ESPTracerOrigin == "Mouse" then
                    tracerFrom = UserInputService:GetMouseLocation()
                else
                    tracerFrom = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                end
                
                esp.Tracer.From = tracerFrom
                esp.Tracer.To = Vector2.new(screenPos.X, screenPos.Y + boxHeight/2)
                esp.Tracer.Color = Settings.ESPTracerColor
            else
                esp.Tracer.Visible = false
            end
            
            -- Head Dot ESP
            if Settings.ESPHeadDotEnabled then
                local headScreen = Camera:WorldToScreenPoint(head.Position)
                if headScreen.Z > 0 then
                    esp.HeadDot.Visible = true
                    esp.HeadDot.Position = Vector2.new(headScreen.X, headScreen.Y)
                    esp.HeadDot.Radius = math.clamp(5 * (1 / screenPos.Z * 10), 2, 20)
                else
                    esp.HeadDot.Visible = false
                end
            else
                esp.HeadDot.Visible = false
            end
            
            -- Weapon ESP
            if Settings.ESPWeaponEnabled then
                local tool = nil
                for _, item in pairs(char:GetChildren()) do
                    if item:IsA("Tool") then
                        tool = item
                        break
                    end
                end
                
                if tool then
                    esp.Weapon.Visible = true
                    esp.Weapon.Position = Vector2.new(screenPos.X, screenPos.Y + boxHeight/2 + 20)
                    esp.Weapon.Text = "[" .. tool.Name .. "]"
                else
                    esp.Weapon.Visible = false
                end
            else
                esp.Weapon.Visible = false
            end
            
            -- Skeleton ESP
            if Settings.ESPSkeletonEnabled then
                local function getPartPosition(partName)
                    local part = char:FindFirstChild(partName)
                    if part then
                        local pos, vis = Camera:WorldToScreenPoint(part.Position)
                        if vis then
                            return Vector2.new(pos.X, pos.Y), true
                        end
                    end
                    return nil, false
                end
                
                local function drawBone(line, part1Name, part2Name)
                    local pos1, vis1 = getPartPosition(part1Name)
                    local pos2, vis2 = getPartPosition(part2Name)
                    
                    if vis1 and vis2 then
                        line.Visible = true
                        line.From = pos1
                        line.To = pos2
                        line.Color = Settings.ESPSkeletonColor
                    else
                        line.Visible = false
                    end
                end
                
                -- R15 Skeleton
                drawBone(esp.Skeleton.Head_UpperTorso, "Head", "UpperTorso")
                drawBone(esp.Skeleton.UpperTorso_LowerTorso, "UpperTorso", "LowerTorso")
                drawBone(esp.Skeleton.UpperTorso_LeftUpperArm, "UpperTorso", "LeftUpperArm")
                drawBone(esp.Skeleton.LeftUpperArm_LeftLowerArm, "LeftUpperArm", "LeftLowerArm")
                drawBone(esp.Skeleton.LeftLowerArm_LeftHand, "LeftLowerArm", "LeftHand")
                drawBone(esp.Skeleton.UpperTorso_RightUpperArm, "UpperTorso", "RightUpperArm")
                drawBone(esp.Skeleton.RightUpperArm_RightLowerArm, "RightUpperArm", "RightLowerArm")
                drawBone(esp.Skeleton.RightLowerArm_RightHand, "RightLowerArm", "RightHand")
                drawBone(esp.Skeleton.LowerTorso_LeftUpperLeg, "LowerTorso", "LeftUpperLeg")
                drawBone(esp.Skeleton.LeftUpperLeg_LeftLowerLeg, "LeftUpperLeg", "LeftLowerLeg")
                drawBone(esp.Skeleton.LeftLowerLeg_LeftFoot, "LeftLowerLeg", "LeftFoot")
                drawBone(esp.Skeleton.LowerTorso_RightUpperLeg, "LowerTorso", "RightUpperLeg")
                drawBone(esp.Skeleton.RightUpperLeg_RightLowerLeg, "RightUpperLeg", "RightLowerLeg")
                drawBone(esp.Skeleton.RightLowerLeg_RightFoot, "RightLowerLeg", "RightFoot")
            else
                for _, line in pairs(esp.Skeleton) do
                    line.Visible = false
                end
            end
        else
            -- Off screen - hide all
            esp.Box.Visible = false
            esp.BoxOutline.Visible = false
            esp.Name.Visible = false
            esp.Distance.Visible = false
            esp.Health.Visible = false
            esp.HealthBG.Visible = false
            esp.HealthOutline.Visible = false
            esp.Tracer.Visible = false
            esp.HeadDot.Visible = false
            esp.Weapon.Visible = false
            for _, line in pairs(esp.Skeleton) do
                line.Visible = false
            end
        end
    end
end

-- Initialize ESP for existing players
for _, player in pairs(Players:GetPlayers()) do
    createESPForPlayer(player)
end

-- Connect player events
Players.PlayerAdded:Connect(createESPForPlayer)
Players.PlayerRemoving:Connect(removeESPForPlayer)

-- ESP Update Loop
Connections["ESPUpdate"] = RunService.RenderStepped:Connect(updateCustomESP)

-- Custom ESP UI Toggles
CustomESPSection:AddToggle({
    ["Name"] = "| Box ESP (Custom)",
    ["Callback"] = function(Value)
        Settings.ESPBoxEnabled = Value
    end
})

CustomESPSection:AddToggle({
    ["Name"] = "| Name ESP (Custom)",
    ["Callback"] = function(Value)
        Settings.ESPNameEnabled = Value
    end
})

CustomESPSection:AddToggle({
    ["Name"] = "| Health ESP (Custom)",
    ["Callback"] = function(Value)
        Settings.ESPHealthEnabled = Value
    end
})

CustomESPSection:AddToggle({
    ["Name"] = "| Distance ESP (Custom)",
    ["Callback"] = function(Value)
        Settings.ESPDistanceEnabled = Value
    end
})

CustomESPSection:AddToggle({
    ["Name"] = "| Tracer ESP (Custom)",
    ["Callback"] = function(Value)
        Settings.ESPTracerEnabled = Value
    end
})

CustomESPSection:AddToggle({
    ["Name"] = "| Skeleton ESP (Custom)",
    ["Callback"] = function(Value)
        Settings.ESPSkeletonEnabled = Value
    end
})

CustomESPSection:AddToggle({
    ["Name"] = "| Head Dot ESP",
    ["Callback"] = function(Value)
        Settings.ESPHeadDotEnabled = Value
    end
})

CustomESPSection:AddToggle({
    ["Name"] = "| Weapon ESP",
    ["Callback"] = function(Value)
        Settings.ESPWeaponEnabled = Value
    end
})

CustomESPSection:AddDropdown({
    ["Name"] = "Tracer Origin",
    ["List"] = {"Bottom", "Top", "Center", "Mouse"},
    ["Callback"] = function(Value)
        Settings.ESPTracerOrigin = Value
    end
})


--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 19: VISUALS TAB - HIGHLIGHT & CHAMS SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local HighlightSection = VisualsTab:CreateSection({
    ["Name"] = "|Highlight & Chams|",
    ["Side"] = "Right"
})

-- Highlight ESP
HighlightSection:AddToggle({
    ["Name"] = "| Highlight ESP",
    ["Callback"] = function(Value)
        Settings.HighlightEnabled = Value
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local existing = player.Character:FindFirstChild("ESPHighlight")
                
                if Value then
                    if not existing then
                        local highlight = Instance.new("Highlight")
                        highlight.Name = "ESPHighlight"
                        highlight.FillColor = Settings.HighlightFillColor
                        highlight.OutlineColor = Settings.HighlightOutlineColor
                        highlight.FillTransparency = Settings.HighlightFillTransparency
                        highlight.OutlineTransparency = Settings.HighlightOutlineTransparency
                        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                        highlight.Parent = player.Character
                    end
                else
                    if existing then existing:Destroy() end
                end
            end
        end
        
        -- Connect to new players
        if Value then
            Connections["HighlightESP"] = Players.PlayerAdded:Connect(function(player)
                player.CharacterAdded:Connect(function(char)
                    task.wait(1)
                    if Settings.HighlightEnabled then
                        local highlight = Instance.new("Highlight")
                        highlight.Name = "ESPHighlight"
                        highlight.FillColor = Settings.HighlightFillColor
                        highlight.OutlineColor = Settings.HighlightOutlineColor
                        highlight.FillTransparency = Settings.HighlightFillTransparency
                        highlight.OutlineTransparency = Settings.HighlightOutlineTransparency
                        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                        highlight.Parent = char
                    end
                end)
            end)
        else
            if Connections["HighlightESP"] then
                Connections["HighlightESP"]:Disconnect()
                Connections["HighlightESP"] = nil
            end
        end
    end
})

-- Highlight Fill Transparency
HighlightSection:AddSlider({
    ["Min"] = 0,
    ["Max"] = 1,
    ["Name"] = "Fill Transparency",
    ["Value"] = 0.5,
    ["Decimals"] = 2,
    ["Callback"] = function(Value)
        Settings.HighlightFillTransparency = Value
        for _, player in pairs(Players:GetPlayers()) do
            if player.Character then
                local highlight = player.Character:FindFirstChild("ESPHighlight")
                if highlight then
                    highlight.FillTransparency = Value
                end
            end
        end
    end
})

-- Highlight Outline Transparency
HighlightSection:AddSlider({
    ["Min"] = 0,
    ["Max"] = 1,
    ["Name"] = "Outline Transparency",
    ["Value"] = 0,
    ["Decimals"] = 2,
    ["Callback"] = function(Value)
        Settings.HighlightOutlineTransparency = Value
        for _, player in pairs(Players:GetPlayers()) do
            if player.Character then
                local highlight = player.Character:FindFirstChild("ESPHighlight")
                if highlight then
                    highlight.OutlineTransparency = Value
                end
            end
        end
    end
})

-- Chams
ChamsFolder = Instance.new("Folder")
ChamsFolder.Name = "BrunoChams"
ChamsFolder.Parent = CoreGui

local function createChams(player)
    if player == LocalPlayer then return end
    
    local char = player.Character
    if not char then return end
    
    local existing = ChamsFolder:FindFirstChild(player.Name)
    if existing then existing:Destroy() end
    
    local playerFolder = Instance.new("Folder")
    playerFolder.Name = player.Name
    playerFolder.Parent = ChamsFolder
    
    for _, part in pairs(char:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            local box = Instance.new("BoxHandleAdornment")
            box.Name = part.Name .. "_Cham"
            box.Adornee = part
            box.AlwaysOnTop = true
            box.ZIndex = 5
            box.Size = part.Size + Vector3.new(0.1, 0.1, 0.1)
            box.Transparency = Settings.ChamsFillTransparency
            box.Color3 = Settings.ChamsColor
            box.Parent = playerFolder
        end
    end
end

local function removeChams(player)
    local existing = ChamsFolder:FindFirstChild(player.Name)
    if existing then existing:Destroy() end
end

local function updateChams()
    if not Settings.ChamsEnabled then
        for _, folder in pairs(ChamsFolder:GetChildren()) do
            folder:Destroy()
        end
        return
    end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local char = player.Character
            if char then
                local existing = ChamsFolder:FindFirstChild(player.Name)
                if not existing then
                    createChams(player)
                else
                    for _, box in pairs(existing:GetChildren()) do
                        box.Color3 = Settings.ChamsColor
                        box.Transparency = Settings.ChamsFillTransparency
                    end
                end
            end
        end
    end
end

HighlightSection:AddToggle({
    ["Name"] = "| Chams",
    ["Callback"] = function(Value)
        Settings.ChamsEnabled = Value
        if not Value then
            for _, folder in pairs(ChamsFolder:GetChildren()) do
                folder:Destroy()
            end
        end
    end
})

HighlightSection:AddSlider({
    ["Min"] = 0,
    ["Max"] = 1,
    ["Name"] = "Chams Transparency",
    ["Value"] = 0.5,
    ["Decimals"] = 2,
    ["Callback"] = function(Value)
        Settings.ChamsFillTransparency = Value
    end
})

-- Chams update loop
spawn(function()
    while true do
        if Settings.ChamsEnabled then
            updateChams()
        end
        task.wait(1)
    end
end)

-- Connect chams to character spawns
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function()
            if Settings.ChamsEnabled then
                task.wait(1)
                createChams(player)
            end
        end)
    end
end

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function()
        if Settings.ChamsEnabled then
            task.wait(1)
            createChams(player)
        end
    end)
end)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 20: VISUALS TAB - CROSSHAIR SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local CrosshairSection = VisualsTab:CreateSection({
    ["Name"] = "|Crosshair|",
    ["Side"] = "Right"
})

-- Create crosshair lines
CrosshairLines = {
    Top = Drawing.new("Line"),
    Bottom = Drawing.new("Line"),
    Left = Drawing.new("Line"),
    Right = Drawing.new("Line"),
    Dot = Drawing.new("Circle")
}

for name, line in pairs(CrosshairLines) do
    if name ~= "Dot" then
        line.Visible = false
        line.Color = Settings.CrosshairColor
        line.Thickness = Settings.CrosshairThickness
    end
end

CrosshairLines.Dot.Visible = false
CrosshairLines.Dot.Color = Settings.CrosshairColor
CrosshairLines.Dot.Filled = true
CrosshairLines.Dot.NumSides = 32
CrosshairLines.Dot.Radius = Settings.CrosshairDotSize

CrosshairSection:AddToggle({
    ["Name"] = "| Custom Crosshair",
    ["Callback"] = function(Value)
        Settings.CrosshairEnabled = Value
        for name, line in pairs(CrosshairLines) do
            if name ~= "Dot" then
                line.Visible = Value
            end
        end
        if Settings.CrosshairDot then
            CrosshairLines.Dot.Visible = Value
        end
    end
})

CrosshairSection:AddSlider({
    ["Min"] = 5,
    ["Max"] = 30,
    ["Name"] = "Crosshair Size",
    ["Value"] = 10,
    ["Decimals"] = 0,
    ["Callback"] = function(Value)
        Settings.CrosshairSize = Value
    end
})

CrosshairSection:AddSlider({
    ["Min"] = 0,
    ["Max"] = 20,
    ["Name"] = "Crosshair Gap",
    ["Value"] = 5,
    ["Decimals"] = 0,
    ["Callback"] = function(Value)
        Settings.CrosshairGap = Value
    end
})

CrosshairSection:AddSlider({
    ["Min"] = 1,
    ["Max"] = 5,
    ["Name"] = "Crosshair Thickness",
    ["Value"] = 2,
    ["Decimals"] = 0,
    ["Callback"] = function(Value)
        Settings.CrosshairThickness = Value
        for name, line in pairs(CrosshairLines) do
            if name ~= "Dot" then
                line.Thickness = Value
            end
        end
    end
})

CrosshairSection:AddToggle({
    ["Name"] = "| Center Dot",
    ["Callback"] = function(Value)
        Settings.CrosshairDot = Value
        CrosshairLines.Dot.Visible = Value and Settings.CrosshairEnabled
    end
})

CrosshairSection:AddSlider({
    ["Min"] = 1,
    ["Max"] = 10,
    ["Name"] = "Dot Size",
    ["Value"] = 2,
    ["Decimals"] = 0,
    ["Callback"] = function(Value)
        Settings.CrosshairDotSize = Value
        CrosshairLines.Dot.Radius = Value
    end
})

-- Crosshair Update Loop
Connections["CrosshairUpdate"] = RunService.RenderStepped:Connect(function()
    if Settings.CrosshairEnabled then
        local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        
        CrosshairLines.Top.From = center - Vector2.new(0, Settings.CrosshairGap)
        CrosshairLines.Top.To = center - Vector2.new(0, Settings.CrosshairGap + Settings.CrosshairSize)
        CrosshairLines.Top.Color = Settings.CrosshairColor
        
        CrosshairLines.Bottom.From = center + Vector2.new(0, Settings.CrosshairGap)
        CrosshairLines.Bottom.To = center + Vector2.new(0, Settings.CrosshairGap + Settings.CrosshairSize)
        CrosshairLines.Bottom.Color = Settings.CrosshairColor
        
        CrosshairLines.Left.From = center - Vector2.new(Settings.CrosshairGap, 0)
        CrosshairLines.Left.To = center - Vector2.new(Settings.CrosshairGap + Settings.CrosshairSize, 0)
        CrosshairLines.Left.Color = Settings.CrosshairColor
        
        CrosshairLines.Right.From = center + Vector2.new(Settings.CrosshairGap, 0)
        CrosshairLines.Right.To = center + Vector2.new(Settings.CrosshairGap + Settings.CrosshairSize, 0)
        CrosshairLines.Right.Color = Settings.CrosshairColor
        
        if Settings.CrosshairDot then
            CrosshairLines.Dot.Position = center
            CrosshairLines.Dot.Color = Settings.CrosshairColor
            CrosshairLines.Dot.Radius = Settings.CrosshairDotSize
        end
    end
end)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 21: VISUALS TAB - RADAR SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local RadarSection = VisualsTab:CreateSection({
    ["Name"] = "|Radar (Custom)|",
    ["Side"] = "Right"
})

local function createRadar()
    if RadarFrame then RadarFrame:Remove() end
    
    RadarFrame = Drawing.new("Square")
    RadarFrame.Visible = Settings.RadarEnabled
    RadarFrame.Position = Vector2.new(Settings.RadarPositionX, Settings.RadarPositionY)
    RadarFrame.Size = Vector2.new(Settings.RadarSize, Settings.RadarSize)
    RadarFrame.Color = Color3.fromRGB(30, 30, 30)
    RadarFrame.Filled = true
    RadarFrame.Transparency = 0.8
    RadarFrame.Thickness = 2
    
    RadarCenterDot = Drawing.new("Circle")
    RadarCenterDot.Visible = Settings.RadarEnabled
    RadarCenterDot.Position = Vector2.new(Settings.RadarPositionX + Settings.RadarSize/2, Settings.RadarPositionY + Settings.RadarSize/2)
    RadarCenterDot.Radius = 3
    RadarCenterDot.Color = Color3.fromRGB(0, 255, 0)
    RadarCenterDot.Filled = true
end

local function updateRadar()
    if not Settings.RadarEnabled then
        if RadarFrame then RadarFrame.Visible = false end
        if RadarCenterDot then RadarCenterDot.Visible = false end
        for _, dot in pairs(RadarDots) do
            if dot then dot.Visible = false end
        end
        return
    end
    
    if not RadarFrame then createRadar() end
    
    RadarFrame.Visible = true
    RadarCenterDot.Visible = true
    
    local myHRP = getHRP()
    if not myHRP then return end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local theirHRP = player.Character:FindFirstChild("HumanoidRootPart")
            if theirHRP then
                if not RadarDots[player] then
                    RadarDots[player] = Drawing.new("Circle")
                    RadarDots[player].Radius = 3
                    RadarDots[player].Color = Color3.fromRGB(255, 0, 0)
                    RadarDots[player].Filled = true
                end
                
                local offset = (theirHRP.Position - myHRP.Position) / Settings.RadarScale
                local _, yRot, _ = Camera.CFrame:ToEulerAnglesYXZ()
                local rotatedOffset = CFrame.Angles(0, -yRot, 0) * Vector3.new(offset.X, 0, offset.Z)
                
                local radarX = Settings.RadarPositionX + Settings.RadarSize/2 + math.clamp(rotatedOffset.X, -Settings.RadarSize/2 + 5, Settings.RadarSize/2 - 5)
                local radarY = Settings.RadarPositionY + Settings.RadarSize/2 + math.clamp(rotatedOffset.Z, -Settings.RadarSize/2 + 5, Settings.RadarSize/2 - 5)
                
                RadarDots[player].Position = Vector2.new(radarX, radarY)
                RadarDots[player].Visible = true
            end
        else
            if RadarDots[player] then
                RadarDots[player].Visible = false
            end
        end
    end
end

Connections["RadarUpdate"] = RunService.RenderStepped:Connect(updateRadar)

RadarSection:AddToggle({
    ["Name"] = "| Radar",
    ["Callback"] = function(Value)
        Settings.RadarEnabled = Value
        if Value and not RadarFrame then
            createRadar()
        end
    end
})

RadarSection:AddSlider({
    ["Min"] = 50,
    ["Max"] = 300,
    ["Name"] = "Radar Size",
    ["Value"] = 150,
    ["Decimals"] = 0,
    ["Callback"] = function(Value)
        Settings.RadarSize = Value
        if RadarFrame then
            RadarFrame.Size = Vector2.new(Value, Value)
            if RadarCenterDot then
                RadarCenterDot.Position = Vector2.new(Settings.RadarPositionX + Value/2, Settings.RadarPositionY + Value/2)
            end
        end
    end
})

RadarSection:AddSlider({
    ["Min"] = 5,
    ["Max"] = 50,
    ["Name"] = "Radar Scale",
    ["Value"] = 10,
    ["Decimals"] = 0,
    ["Callback"] = function(Value)
        Settings.RadarScale = Value
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 22: VISUALS TAB - WORLD SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local WorldSection = VisualsTab:CreateSection({
    ["Name"] = "|World|",
    ["Side"] = "Right"
})

-- Remove Fog
WorldSection:AddButton({
    ["Name"] = "Remove All Fog",
    ["Callback"] = function()
        Lighting.FogEnd = 100000
        Lighting.FogStart = 0
        for _, v in pairs(Lighting:GetDescendants()) do
            if v:IsA("Atmosphere") then
                v.Density = 0
            end
        end
        sendNotification("Fog Removed", "All fog effects removed!")
    end
})

-- Set Day Time
WorldSection:AddButton({
    ["Name"] = "Set Day Time",
    ["Callback"] = function()
        Lighting.ClockTime = 12
    end
})

-- Set Night Time
WorldSection:AddButton({
    ["Name"] = "Set Night Time",
    ["Callback"] = function()
        Lighting.ClockTime = 0
    end
})

-- Time Slider
WorldSection:AddSlider({
    ["Min"] = 0,
    ["Max"] = 24,
    ["Name"] = "Time of Day",
    ["Value"] = 12,
    ["Decimals"] = 1,
    ["Callback"] = function(Value)
        Lighting.ClockTime = Value
    end
})

-- Remove Invisible Walls
WorldSection:AddButton({
    ["Name"] = "Remove Invisible Walls",
    ["Callback"] = function()
        local count = 0
        for _, v in pairs(Workspace:GetDescendants()) do
            if v:IsA("BasePart") and v.Transparency >= 0.9 and v.CanCollide then
                v.CanCollide = false
                count = count + 1
            end
        end
        sendNotification("Walls Removed", "Removed " .. count .. " invisible walls!")
    end
})

-- Unlock All Doors
WorldSection:AddButton({
    ["Name"] = "Unlock All Doors",
    ["Callback"] = function()
        local count = 0
        for _, v in pairs(Workspace:GetDescendants()) do
            if v:IsA("BasePart") and (string.lower(v.Name):find("door") or string.lower(v.Name):find("gate")) then
                v.CanCollide = false
                count = count + 1
            end
        end
        sendNotification("Doors Unlocked", "Unlocked " .. count .. " doors!")
    end
})


--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 23: VISUALS TAB - KILL EFFECTS SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local KillEffectsSection = VisualsTab:CreateSection({
    ["Name"] = "|Kill Effects|",
    ["Side"] = "Left"
})

local KillEffectsEnabled = false
local KillEffectType = "Explosion"
local KillSoundEnabled = false
local KillSoundId = ""

KillEffectsSection:AddToggle({
    ["Name"] = "| Kill Effects",
    ["Callback"] = function(Value)
        KillEffectsEnabled = Value
    end
})

KillEffectsSection:AddDropdown({
    ["Name"] = "Effect Type",
    ["List"] = {"Explosion", "Fire", "Sparkles", "Smoke", "Neon", "Dissolve"},
    ["Callback"] = function(Value)
        KillEffectType = Value
    end
})

KillEffectsSection:AddToggle({
    ["Name"] = "| Kill Sound",
    ["Callback"] = function(Value)
        KillSoundEnabled = Value
    end
})

KillEffectsSection:AddTextbox({
    ["Name"] = "Sound ID",
    ["Value"] = "",
    ["Callback"] = function(Value)
        KillSoundId = "rbxassetid://" .. Value
    end
})

-- Monitor for kills
local function onPlayerDied(player)
    if not KillEffectsEnabled then return end
    if player == LocalPlayer then return end
    
    local char = player.Character
    if not char then return end
    
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    -- Play kill sound
    if KillSoundEnabled and KillSoundId ~= "" then
        local sound = Instance.new("Sound")
        sound.SoundId = KillSoundId
        sound.Volume = 1
        sound.Parent = hrp
        sound:Play()
        Debris:AddItem(sound, 5)
    end
    
    -- Apply kill effect
    if KillEffectType == "Explosion" then
        local explosion = Instance.new("Explosion")
        explosion.Position = hrp.Position
        explosion.BlastPressure = 0
        explosion.BlastRadius = 0
        explosion.Parent = Workspace
        Debris:AddItem(explosion, 2)
        
    elseif KillEffectType == "Fire" then
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                local fire = Instance.new("Fire")
                fire.Heat = 25
                fire.Size = 15
                fire.Parent = part
                Debris:AddItem(fire, 3)
            end
        end
        
    elseif KillEffectType == "Sparkles" then
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                local sparkles = Instance.new("Sparkles")
                sparkles.SparkleColor = Color3.fromRGB(255, 215, 0)
                sparkles.Parent = part
                Debris:AddItem(sparkles, 3)
            end
        end
        
    elseif KillEffectType == "Smoke" then
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                local smoke = Instance.new("Smoke")
                smoke.Color = Color3.fromRGB(50, 50, 50)
                smoke.Size = 5
                smoke.Parent = part
                Debris:AddItem(smoke, 3)
            end
        end
        
    elseif KillEffectType == "Neon" then
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Material = Enum.Material.Neon
                part.BrickColor = BrickColor.new("Really red")
            end
        end
        
    elseif KillEffectType == "Dissolve" then
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                local tween = TweenService:Create(part, TweenInfo.new(2), {Transparency = 1})
                tween:Play()
            end
        end
    end
end

-- Connect to all player deaths
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function(char)
            local hum = char:WaitForChild("Humanoid", 10)
            if hum then
                hum.Died:Connect(function()
                    onPlayerDied(player)
                end)
            end
        end)
    end
end

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(char)
        local hum = char:WaitForChild("Humanoid", 10)
        if hum then
            hum.Died:Connect(function()
                onPlayerDied(player)
            end)
        end
    end)
end)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 24: FARM TAB - FARMS SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local FarmSection = FarmTab:CreateSection({
    ["Name"] = "|Farms|",
    ["Side"] = "Left"
})

-- Box Autofarm
FarmSection:AddButton({
    ["Name"] = "Box Autofarm",
    ["Callback"] = function()
        spawn(function()
            for _, v in pairs(Workspace:GetDescendants()) do
                if v:IsA("ProximityPrompt") then
                    local hrp = getHRP()
                    if hrp and v.Parent and v.Parent:IsA("BasePart") then
                        hrp.CFrame = v.Parent.CFrame + Vector3.new(0, 3, 0)
                        task.wait(0.3)
                        firePrompt(v)
                        task.wait(0.5)
                    end
                end
            end
            sendNotification("Box Farm", "Completed box farm!")
        end)
    end
})

-- Chips Autofarm
FarmSection:AddButton({
    ["Name"] = "Chips Autofarm",
    ["Callback"] = function()
        spawn(function()
            for _, v in pairs(Workspace:GetDescendants()) do
                if v:IsA("BasePart") and string.lower(v.Name):find("chip") then
                    local hrp = getHRP()
                    if hrp then
                        hrp.CFrame = v.CFrame + Vector3.new(0, 3, 0)
                        task.wait(0.5)
                    end
                end
            end
            sendNotification("Chips Farm", "Completed chips farm!")
        end)
    end
})

-- Marshmallow Autofarm
FarmSection:AddButton({
    ["Name"] = "MarshMallow Autofarm",
    ["Callback"] = function()
        spawn(function()
            for _, v in pairs(Workspace:GetDescendants()) do
                if v:IsA("BasePart") and (string.lower(v.Name):find("marsh") or string.lower(v.Name):find("mallow")) then
                    local hrp = getHRP()
                    if hrp then
                        hrp.CFrame = v.CFrame + Vector3.new(0, 3, 0)
                        task.wait(0.5)
                    end
                end
            end
            sendNotification("Marshmallow Farm", "Completed marshmallow farm!")
        end)
    end
})

-- Rob Farm (PASTEBIN)
FarmSection:AddButton({
    ["Name"] = "Rob Farm",
    ["Callback"] = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/pEQp1kpP"))()
        sendNotification("Rob Farm", "Rob farm loaded!")
    end
})

-- Auto Collect Items
FarmSection:AddToggle({
    ["Name"] = "| Auto Collect Items",
    ["Callback"] = function(Value)
        Settings.AutoCollectEnabled = Value
        
        if Value then
            Connections["AutoCollect"] = RunService.Heartbeat:Connect(function()
                if Settings.AutoCollectEnabled then
                    local hrp = getHRP()
                    if hrp then
                        for _, v in pairs(Workspace:GetDescendants()) do
                            if v:IsA("ProximityPrompt") and v.Parent and v.Parent:IsA("BasePart") then
                                local dist = (v.Parent.Position - hrp.Position).Magnitude
                                if dist <= Settings.AutoCollectRadius then
                                    firePrompt(v)
                                end
                            end
                        end
                    end
                end
            end)
        else
            if Connections["AutoCollect"] then
                Connections["AutoCollect"]:Disconnect()
                Connections["AutoCollect"] = nil
            end
        end
    end
})

FarmSection:AddSlider({
    ["Min"] = 10,
    ["Max"] = 200,
    ["Name"] = "Collect Radius",
    ["Value"] = 50,
    ["Decimals"] = 0,
    ["Callback"] = function(Value)
        Settings.AutoCollectRadius = Value
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 25: FARM TAB - AUTO FARM STATES SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local AutoFarmSection = FarmTab:CreateSection({
    ["Name"] = "|Auto Farm States|",
    ["Side"] = "Right"
})

-- Send Webhook on Death
AutoFarmSection:AddToggle({
    ["Flag"] = "StatsSection_SendWebhookonDeath",
    ["Name"] = "| Send Webhook on Death",
    ["Callback"] = function(Value)
        Settings.WebhookOnDeath = Value
    end
})

AutoFarmSection:AddTextbox({
    ["Value"] = "",
    ["Name"] = "Webhook on death",
    ["Callback"] = function(Value)
        Settings.WebhookURL = Value
    end
})

-- Remove Players Visual
AutoFarmSection:AddToggle({
    ["Flag"] = "StatsSection_RemovePlayers(Visual)",
    ["Name"] = "| Remove Players ( Visual )",
    ["Callback"] = function(Value)
        if Value then
            Connections["RemovePlayers"] = RunService.Heartbeat:Connect(function()
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and player.Character then
                        local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            hrp.CFrame = CFrame.new(0, 10000, 0)
                        end
                    end
                end
            end)
        else
            if Connections["RemovePlayers"] then
                Connections["RemovePlayers"]:Disconnect()
                Connections["RemovePlayers"] = nil
            end
        end
    end
})

-- Freeze Cam Position
local FreezeCamPos = nil
AutoFarmSection:AddToggle({
    ["Flag"] = "FreezeCam",
    ["Name"] = "| Freeze Cam Position",
    ["Callback"] = function(Value)
        if Value then
            FreezeCamPos = Camera.CFrame
            Connections["FreezeCam"] = RunService.RenderStepped:Connect(function()
                if FreezeCamPos then
                    Camera.CFrame = FreezeCamPos
                end
            end)
        else
            FreezeCamPos = nil
            if Connections["FreezeCam"] then
                Connections["FreezeCam"]:Disconnect()
                Connections["FreezeCam"] = nil
            end
        end
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 26: FARM TAB - ATM SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local AtmSection = FarmTab:CreateSection({
    ["Name"] = "|Atm Mods|",
    ["Side"] = "Right"
})

-- Find ATMs
local ATMLocations = {}
local function findATMs()
    ATMLocations = {}
    for _, v in pairs(Workspace:GetDescendants()) do
        if v:IsA("BasePart") and string.lower(v.Name):find("atm") then
            table.insert(ATMLocations, v)
        end
    end
    return ATMLocations
end
findATMs()

local ATMNames = {}
for i, atm in pairs(ATMLocations) do
    table.insert(ATMNames, "ATM " .. i)
end

local SelectedATMIndex = 1

AtmSection:AddDropdown({
    ["Name"] = "Atm Locations",
    ["List"] = #ATMNames > 0 and ATMNames or {"No ATMs Found"},
    ["Callback"] = function(Value)
        for i, name in pairs(ATMNames) do
            if name == Value then
                SelectedATMIndex = i
                break
            end
        end
    end
})

AtmSection:AddButton({
    ["Name"] = "| View ATM List",
    ["Callback"] = function()
        findATMs()
        print("=== ATM LOCATIONS ===")
        for i, atm in pairs(ATMLocations) do
            print(i .. ". " .. atm.Name .. " at " .. tostring(atm.Position))
        end
        print("=====================")
        sendNotification("ATM List", "Found " .. #ATMLocations .. " ATMs (check output)")
    end
})

AtmSection:AddButton({
    ["Name"] = "Teleport To Atm Location",
    ["Callback"] = function()
        if ATMLocations[SelectedATMIndex] then
            local hrp = getHRP()
            if hrp then
                hrp.CFrame = ATMLocations[SelectedATMIndex].CFrame + Vector3.new(0, 5, 0)
                sendNotification("Teleported", "Teleported to ATM " .. SelectedATMIndex)
            end
        else
            sendNotification("Error", "ATM not found!")
        end
    end
})

AtmSection:AddButton({
    ["Name"] = "Refresh ATM List",
    ["Callback"] = function()
        findATMs()
        ATMNames = {}
        for i, atm in pairs(ATMLocations) do
            table.insert(ATMNames, "ATM " .. i)
        end
        sendNotification("Refreshed", "Found " .. #ATMLocations .. " ATMs")
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 27: FARM TAB - CAR MODS SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local CarSection = FarmTab:CreateSection({
    ["Name"] = "|Car Mods|",
    ["Side"] = "Left"
})

-- Car Speed
local CarSpeedValue = 100
CarSection:AddToggle({
    ["Name"] = "| Car Speed Boost",
    ["Callback"] = function(Value)
        if Value then
            Connections["CarSpeed"] = RunService.Heartbeat:Connect(function()
                local hum = getHumanoid()
                if hum and hum.SeatPart then
                    local car = hum.SeatPart.Parent
                    if car then
                        for _, v in pairs(car:GetDescendants()) do
                            if v:IsA("NumberValue") and (string.lower(v.Name):find("speed") or string.lower(v.Name):find("velocity")) then
                                v.Value = CarSpeedValue
                            end
                        end
                    end
                end
            end)
        else
            if Connections["CarSpeed"] then
                Connections["CarSpeed"]:Disconnect()
                Connections["CarSpeed"] = nil
            end
        end
    end
})

CarSection:AddSlider({
    ["Min"] = 10,
    ["Max"] = 1000,
    ["Name"] = "Car Speed",
    ["Value"] = 100,
    ["Decimals"] = 0,
    ["Callback"] = function(Value)
        CarSpeedValue = Value
    end
})

-- Car Fly
CarSection:AddToggle({
    ["Name"] = "| Car Fly",
    ["Callback"] = function(Value)
        local hum = getHumanoid()
        if hum and hum.SeatPart then
            local car = hum.SeatPart.Parent
            if car then
                local mainPart = car:FindFirstChild("VehicleSeat") or car.PrimaryPart or hum.SeatPart
                
                if Value then
                    local bv = Instance.new("BodyVelocity")
                    bv.Name = "CarFlyBV"
                    bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                    bv.Velocity = Vector3.new(0, 0, 0)
                    bv.Parent = mainPart
                    
                    local bg = Instance.new("BodyGyro")
                    bg.Name = "CarFlyBG"
                    bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                    bg.P = 9e4
                    bg.Parent = mainPart
                else
                    local bv = mainPart:FindFirstChild("CarFlyBV")
                    local bg = mainPart:FindFirstChild("CarFlyBG")
                    if bv then bv:Destroy() end
                    if bg then bg:Destroy() end
                end
            end
        end
    end
})

-- Car Noclip
CarSection:AddToggle({
    ["Name"] = "| Car Noclip",
    ["Callback"] = function(Value)
        if Value then
            Connections["CarNoclip"] = RunService.Stepped:Connect(function()
                local hum = getHumanoid()
                if hum and hum.SeatPart then
                    local car = hum.SeatPart.Parent
                    if car then
                        for _, part in pairs(car:GetDescendants()) do
                            if part:IsA("BasePart") then
                                part.CanCollide = false
                            end
                        end
                    end
                end
            end)
        else
            if Connections["CarNoclip"] then
                Connections["CarNoclip"]:Disconnect()
                Connections["CarNoclip"] = nil
            end
        end
    end
})

-- Infinite Fuel
CarSection:AddToggle({
    ["Name"] = "| Infinite Fuel",
    ["Callback"] = function(Value)
        if Value then
            Connections["InfiniteFuel"] = RunService.Heartbeat:Connect(function()
                local hum = getHumanoid()
                if hum and hum.SeatPart then
                    local car = hum.SeatPart.Parent
                    if car then
                        for _, v in pairs(car:GetDescendants()) do
                            if v:IsA("NumberValue") and string.lower(v.Name):find("fuel") then
                                v.Value = 100
                            end
                        end
                    end
                end
            end)
        else
            if Connections["InfiniteFuel"] then
                Connections["InfiniteFuel"]:Disconnect()
                Connections["InfiniteFuel"] = nil
            end
        end
    end
})

-- Car Jump
CarSection:AddButton({
    ["Name"] = "| Car Jump",
    ["Callback"] = function()
        local hum = getHumanoid()
        if hum and hum.SeatPart then
            local car = hum.SeatPart.Parent
            if car then
                local mainPart = car:FindFirstChild("VehicleSeat") or car.PrimaryPart or hum.SeatPart
                
                local bv = Instance.new("BodyVelocity")
                bv.MaxForce = Vector3.new(0, math.huge, 0)
                bv.Velocity = Vector3.new(0, 100, 0)
                bv.Parent = mainPart
                
                Debris:AddItem(bv, 0.5)
            end
        end
    end
})

-- Vehicle Mod (GITHUB - Venyx UI)
CarSection:AddToggle({
    ["Name"] = "Vehicle Mod",
    ["Flag"] = "Toggle",
    ["Callback"] = function(Value)
        if Value then
            loadstring(game:HttpGet("https://raw.githubusercontent.com/xovanDJX/Backup/main/Venyx%20UI%20Library"))()
        end
    end
})


--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 28: TELEPORT TAB - TELEPORT SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local TeleportSection = TeleportTab:CreateSection({
    ["Name"] = "|Teleport|",
    ["Side"] = "Left"
})

-- TP to Mouse
TeleportSection:AddToggle({
    ["Name"] = "| TP to Mouse ( E )",
    ["Callback"] = function(Value)
        if Value then
            Connections["TPToMouse"] = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if gameProcessed then return end
                if input.KeyCode == Enum.KeyCode.E then
                    local hrp = getHRP()
                    if hrp then
                        local mousePos = Mouse.Hit.Position
                        hrp.CFrame = CFrame.new(mousePos + Vector3.new(0, 3, 0))
                    end
                end
            end)
        else
            if Connections["TPToMouse"] then
                Connections["TPToMouse"]:Disconnect()
                Connections["TPToMouse"] = nil
            end
        end
    end
})

-- TP to Coords
local TPCoordX = 0
local TPCoordY = 0
local TPCoordZ = 0

TeleportSection:AddTextbox({
    ["Name"] = "X Coordinate",
    ["Value"] = "0",
    ["Callback"] = function(Value)
        TPCoordX = tonumber(Value) or 0
    end
})

TeleportSection:AddTextbox({
    ["Name"] = "Y Coordinate",
    ["Value"] = "0",
    ["Callback"] = function(Value)
        TPCoordY = tonumber(Value) or 0
    end
})

TeleportSection:AddTextbox({
    ["Name"] = "Z Coordinate",
    ["Value"] = "0",
    ["Callback"] = function(Value)
        TPCoordZ = tonumber(Value) or 0
    end
})

TeleportSection:AddButton({
    ["Name"] = "| Teleport to Coords",
    ["Callback"] = function()
        local hrp = getHRP()
        if hrp then
            hrp.CFrame = CFrame.new(TPCoordX, TPCoordY, TPCoordZ)
            sendNotification("Teleported", "Teleported to " .. TPCoordX .. ", " .. TPCoordY .. ", " .. TPCoordZ)
        end
    end
})

TeleportSection:AddButton({
    ["Name"] = "| Tween to Coords",
    ["Callback"] = function()
        local hrp = getHRP()
        if hrp then
            local targetPos = Vector3.new(TPCoordX, TPCoordY, TPCoordZ)
            local dist = (hrp.Position - targetPos).Magnitude
            local duration = dist / 100
            
            tweenTo(targetPos, duration)
            sendNotification("Tweening", "Tweening to coordinates...")
        end
    end
})

TeleportSection:AddButton({
    ["Name"] = "| Copy Current Coords",
    ["Callback"] = function()
        local hrp = getHRP()
        if hrp then
            local coords = string.format("%.2f, %.2f, %.2f", hrp.Position.X, hrp.Position.Y, hrp.Position.Z)
            copyToClipboard(coords)
        end
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 29: TELEPORT TAB - WAYPOINT SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local WaypointSection = TeleportTab:CreateSection({
    ["Name"] = "|Waypoints|",
    ["Side"] = "Right"
})

local SavedWaypoints = {}
local WaypointCount = 0
local SelectedWaypoint = nil

WaypointSection:AddButton({
    ["Name"] = "| Save Current Position",
    ["Callback"] = function()
        local hrp = getHRP()
        if hrp then
            WaypointCount = WaypointCount + 1
            local name = "Waypoint " .. WaypointCount
            SavedWaypoints[name] = hrp.CFrame
            sendNotification("Saved", "Saved " .. name)
            print("Saved waypoint: " .. name .. " at " .. tostring(hrp.Position))
        end
    end
})

WaypointSection:AddTextbox({
    ["Name"] = "Custom Waypoint Name",
    ["Value"] = "",
    ["Callback"] = function(Value)
        if Value ~= "" then
            local hrp = getHRP()
            if hrp then
                SavedWaypoints[Value] = hrp.CFrame
                sendNotification("Saved", "Saved waypoint: " .. Value)
            end
        end
    end
})

WaypointSection:AddTextbox({
    ["Name"] = "Load Waypoint Name",
    ["Value"] = "",
    ["Callback"] = function(Value)
        SelectedWaypoint = Value
    end
})

WaypointSection:AddButton({
    ["Name"] = "| Teleport to Waypoint",
    ["Callback"] = function()
        if SelectedWaypoint and SavedWaypoints[SelectedWaypoint] then
            local hrp = getHRP()
            if hrp then
                hrp.CFrame = SavedWaypoints[SelectedWaypoint]
                sendNotification("Teleported", "Teleported to " .. SelectedWaypoint)
            end
        else
            sendNotification("Error", "Waypoint not found!")
        end
    end
})

WaypointSection:AddButton({
    ["Name"] = "| List All Waypoints",
    ["Callback"] = function()
        print("=== SAVED WAYPOINTS ===")
        for name, cf in pairs(SavedWaypoints) do
            print(name .. ": " .. tostring(cf.Position))
        end
        print("=======================")
        
        local count = 0
        for _ in pairs(SavedWaypoints) do count = count + 1 end
        sendNotification("Waypoints", "You have " .. count .. " saved waypoints (check output)")
    end
})

WaypointSection:AddButton({
    ["Name"] = "| Clear All Waypoints",
    ["Callback"] = function()
        SavedWaypoints = {}
        WaypointCount = 0
        sendNotification("Cleared", "All waypoints cleared!")
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 30: TELEPORT TAB - PLAYER TELEPORT SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local PlayerTPSection = TeleportTab:CreateSection({
    ["Name"] = "|Player Teleport|",
    ["Side"] = "Left"
})

local TPTargetPlayer = nil

PlayerTPSection:AddTextbox({
    ["Name"] = "Player Name",
    ["Value"] = "",
    ["Callback"] = function(Value)
        TPTargetPlayer = findPlayer(Value)
        if TPTargetPlayer then
            sendNotification("Target Set", "TP target: " .. TPTargetPlayer.Name)
        end
    end
})

PlayerTPSection:AddButton({
    ["Name"] = "| Teleport to Player",
    ["Callback"] = function()
        if TPTargetPlayer and TPTargetPlayer.Character then
            local targetHRP = TPTargetPlayer.Character:FindFirstChild("HumanoidRootPart")
            local myHRP = getHRP()
            
            if targetHRP and myHRP then
                myHRP.CFrame = targetHRP.CFrame * CFrame.new(0, 0, 5)
                sendNotification("Teleported", "Teleported to " .. TPTargetPlayer.Name)
            end
        else
            sendNotification("Error", "Target not found!")
        end
    end
})

PlayerTPSection:AddButton({
    ["Name"] = "| Teleport Behind Player",
    ["Callback"] = function()
        if TPTargetPlayer and TPTargetPlayer.Character then
            local targetHRP = TPTargetPlayer.Character:FindFirstChild("HumanoidRootPart")
            local myHRP = getHRP()
            
            if targetHRP and myHRP then
                myHRP.CFrame = targetHRP.CFrame * CFrame.new(0, 0, -5)
                sendNotification("Teleported", "Teleported behind " .. TPTargetPlayer.Name)
            end
        else
            sendNotification("Error", "Target not found!")
        end
    end
})

PlayerTPSection:AddButton({
    ["Name"] = "| Teleport Above Player",
    ["Callback"] = function()
        if TPTargetPlayer and TPTargetPlayer.Character then
            local targetHRP = TPTargetPlayer.Character:FindFirstChild("HumanoidRootPart")
            local myHRP = getHRP()
            
            if targetHRP and myHRP then
                myHRP.CFrame = targetHRP.CFrame * CFrame.new(0, 20, 0)
                sendNotification("Teleported", "Teleported above " .. TPTargetPlayer.Name)
            end
        else
            sendNotification("Error", "Target not found!")
        end
    end
})

PlayerTPSection:AddButton({
    ["Name"] = "| Teleport to Closest Player",
    ["Callback"] = function()
        local closest, dist = getClosestPlayer(math.huge, false, false, false)
        if closest and closest.Character then
            local targetHRP = closest.Character:FindFirstChild("HumanoidRootPart")
            local myHRP = getHRP()
            
            if targetHRP and myHRP then
                myHRP.CFrame = targetHRP.CFrame * CFrame.new(0, 0, 5)
                sendNotification("Teleported", "Teleported to " .. closest.Name .. " (" .. math.floor(dist) .. "m)")
            end
        else
            sendNotification("Error", "No players found!")
        end
    end
})

PlayerTPSection:AddButton({
    ["Name"] = "| Teleport All to You",
    ["Callback"] = function()
        local myHRP = getHRP()
        if myHRP then
            local count = 0
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    local theirHRP = player.Character:FindFirstChild("HumanoidRootPart")
                    if theirHRP then
                        theirHRP.CFrame = myHRP.CFrame * CFrame.new(math.random(-10, 10), 0, math.random(-10, 10))
                        count = count + 1
                    end
                end
            end
            sendNotification("Teleported", "Brought " .. count .. " players to you")
        end
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 31: MISC TAB - CHARACTER EFFECTS SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local CharEffectsSection = MiscTab:CreateSection({
    ["Name"] = "|Character Effects|",
    ["Side"] = "Left"
})

-- Headless
CharEffectsSection:AddToggle({
    ["Name"] = "| Headless",
    ["Callback"] = function(Value)
        local head = getHead()
        if head then
            head.Transparency = Value and 1 or 0
            
            -- Remove face
            local face = head:FindFirstChild("face") or head:FindFirstChildOfClass("Decal")
            if face then
                face.Transparency = Value and 1 or 0
            end
        end
    end
})

-- Corrupted
CharEffectsSection:AddToggle({
    ["Name"] = "| Corrupted",
    ["Callback"] = function(Value)
        if LocalCharacter then
            for _, part in pairs(LocalCharacter:GetDescendants()) do
                if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                    if Value then
                        part.Material = Enum.Material.Neon
                        part.BrickColor = BrickColor.new("Really black")
                    else
                        part.Material = Enum.Material.SmoothPlastic
                    end
                end
            end
        end
    end
})

-- Spin
CharEffectsSection:AddToggle({
    ["Name"] = "| Spin",
    ["Callback"] = function(Value)
        Settings.SpinEnabled = Value
        
        if Value then
            Connections["Spin"] = RunService.Heartbeat:Connect(function()
                if Settings.SpinEnabled then
                    local hrp = getHRP()
                    if hrp then
                        hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(Settings.SpinSpeed), 0)
                    end
                end
            end)
        else
            if Connections["Spin"] then
                Connections["Spin"]:Disconnect()
                Connections["Spin"] = nil
            end
        end
    end
})

CharEffectsSection:AddSlider({
    ["Min"] = 1,
    ["Max"] = 50,
    ["Name"] = "Spin Speed",
    ["Value"] = 10,
    ["Decimals"] = 0,
    ["Callback"] = function(Value)
        Settings.SpinSpeed = Value
    end
})

-- Freeze Character
CharEffectsSection:AddToggle({
    ["Name"] = "| Freeze Character",
    ["Callback"] = function(Value)
        local hrp = getHRP()
        if hrp then
            hrp.Anchored = Value
        end
    end
})

-- Platform Stand
CharEffectsSection:AddToggle({
    ["Name"] = "| Platform Stand",
    ["Callback"] = function(Value)
        local hum = getHumanoid()
        if hum then
            hum.PlatformStand = Value
        end
    end
})

-- Sit
CharEffectsSection:AddToggle({
    ["Name"] = "| Sit",
    ["Callback"] = function(Value)
        local hum = getHumanoid()
        if hum then
            hum.Sit = Value
        end
    end
})

-- Fake Death
CharEffectsSection:AddButton({
    ["Name"] = "| Fake Death",
    ["Callback"] = function()
        local hum = getHumanoid()
        if hum then
            hum:ChangeState(Enum.HumanoidStateType.Physics)
            task.wait(3)
            hum:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
    end
})

-- Ragdoll Toggle
CharEffectsSection:AddToggle({
    ["Name"] = "| Ragdoll Mode",
    ["Callback"] = function(Value)
        local hum = getHumanoid()
        if hum then
            if Value then
                hum:ChangeState(Enum.HumanoidStateType.Ragdoll)
            else
                hum:ChangeState(Enum.HumanoidStateType.GettingUp)
            end
        end
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 32: MISC TAB - CHAT SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local ChatSection = MiscTab:CreateSection({
    ["Name"] = "|Chat|",
    ["Side"] = "Left"
})

-- Chat Spam
ChatSection:AddToggle({
    ["Name"] = "| Chat Spam",
    ["Callback"] = function(Value)
        Settings.ChatSpamEnabled = Value
        
        if Value then
            spawn(function()
                while Settings.ChatSpamEnabled do
                    if Settings.ChatSpamMessage ~= "" then
                        pcall(function()
                            ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents"):FindFirstChild("SayMessageRequest"):FireServer(Settings.ChatSpamMessage, "All")
                        end)
                    end
                    task.wait(Settings.ChatSpamDelay)
                end
            end)
        end
    end
})

ChatSection:AddTextbox({
    ["Name"] = "Spam Message",
    ["Value"] = "",
    ["Callback"] = function(Value)
        Settings.ChatSpamMessage = Value
    end
})

ChatSection:AddSlider({
    ["Min"] = 0.5,
    ["Max"] = 10,
    ["Name"] = "Spam Delay",
    ["Value"] = 1,
    ["Decimals"] = 1,
    ["Callback"] = function(Value)
        Settings.ChatSpamDelay = Value
    end
})

-- Send Message
local MessageToSend = ""
ChatSection:AddTextbox({
    ["Name"] = "Send Message",
    ["Value"] = "",
    ["Callback"] = function(Value)
        MessageToSend = Value
    end
})

ChatSection:AddButton({
    ["Name"] = "| Send Message",
    ["Callback"] = function()
        if MessageToSend ~= "" then
            pcall(function()
                ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents"):FindFirstChild("SayMessageRequest"):FireServer(MessageToSend, "All")
            end)
        end
    end
})

-- Blur Chat
ChatSection:AddButton({
    ["Name"] = "| Blur Chat (Spam Empty)",
    ["Callback"] = function()
        spawn(function()
            for i = 1, 50 do
                pcall(function()
                    ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents"):FindFirstChild("SayMessageRequest"):FireServer("", "All")
                end)
                task.wait(0.1)
            end
        end)
        sendNotification("Blur Chat", "Sent 50 empty messages")
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 33: MISC TAB - TOOL MODS SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local ToolSection = MiscTab:CreateSection({
    ["Name"] = "|Tool Mods|",
    ["Side"] = "Right"
})

-- Extended Reach
local ExtendedReachDistance = 50
ToolSection:AddToggle({
    ["Name"] = "| Extended Reach",
    ["Callback"] = function(Value)
        if Value then
            Connections["ExtendedReach"] = RunService.Heartbeat:Connect(function()
                if LocalCharacter then
                    for _, tool in pairs(LocalCharacter:GetChildren()) do
                        if tool:IsA("Tool") then
                            local handle = tool:FindFirstChild("Handle")
                            if handle then
                                handle.Size = Vector3.new(ExtendedReachDistance, ExtendedReachDistance, ExtendedReachDistance)
                                handle.Transparency = 1
                                handle.Massless = true
                            end
                        end
                    end
                end
            end)
        else
            if Connections["ExtendedReach"] then
                Connections["ExtendedReach"]:Disconnect()
                Connections["ExtendedReach"] = nil
            end
        end
    end
})

ToolSection:AddSlider({
    ["Min"] = 10,
    ["Max"] = 500,
    ["Name"] = "Reach Distance",
    ["Value"] = 50,
    ["Decimals"] = 0,
    ["Callback"] = function(Value)
        ExtendedReachDistance = Value
    end
})

-- Auto Activate Tool
ToolSection:AddToggle({
    ["Name"] = "| Auto Activate Tool",
    ["Callback"] = function(Value)
        if Value then
            Connections["AutoActivate"] = RunService.Heartbeat:Connect(function()
                local tool = getEquippedTool()
                if tool then
                    pcall(function()
                        tool:Activate()
                    end)
                end
            end)
        else
            if Connections["AutoActivate"] then
                Connections["AutoActivate"]:Disconnect()
                Connections["AutoActivate"] = nil
            end
        end
    end
})

-- Equip Closest Tool
ToolSection:AddButton({
    ["Name"] = "| Equip Closest Tool",
    ["Callback"] = function()
        local hrp = getHRP()
        if not hrp then return end
        
        local closest = nil
        local closestDist = math.huge
        
        for _, v in pairs(Workspace:GetDescendants()) do
            if v:IsA("Tool") then
                local handle = v:FindFirstChild("Handle")
                if handle then
                    local dist = (handle.Position - hrp.Position).Magnitude
                    if dist < closestDist then
                        closestDist = dist
                        closest = v
                    end
                end
            end
        end
        
        if closest then
            closest.Parent = LocalCharacter
            sendNotification("Equipped", "Equipped " .. closest.Name)
        else
            sendNotification("Error", "No tools found nearby!")
        end
    end
})

-- Drop All Tools
ToolSection:AddButton({
    ["Name"] = "| Drop All Tools",
    ["Callback"] = function()
        local count = 0
        local hrp = getHRP()
        
        -- From character
        if LocalCharacter then
            for _, tool in pairs(LocalCharacter:GetChildren()) do
                if tool:IsA("Tool") then
                    tool.Parent = Workspace
                    if hrp and tool:FindFirstChild("Handle") then
                        tool.Handle.CFrame = hrp.CFrame * CFrame.new(0, 0, -5)
                    end
                    count = count + 1
                end
            end
        end
        
        -- From backpack
        local backpack = getBackpack()
        if backpack then
            for _, tool in pairs(backpack:GetChildren()) do
                if tool:IsA("Tool") then
                    tool.Parent = Workspace
                    if hrp and tool:FindFirstChild("Handle") then
                        tool.Handle.CFrame = hrp.CFrame * CFrame.new(0, 0, -5)
                    end
                    count = count + 1
                end
            end
        end
        
        sendNotification("Dropped", "Dropped " .. count .. " tools")
    end
})

-- Clone Equipped Tool
ToolSection:AddButton({
    ["Name"] = "| Clone Equipped Tool",
    ["Callback"] = function()
        local tool = getEquippedTool()
        if tool then
            local clone = tool:Clone()
            clone.Parent = getBackpack()
            sendNotification("Cloned", "Cloned " .. tool.Name)
        else
            sendNotification("Error", "No tool equipped!")
        end
    end
})

-- Destroy Equipped Tool
ToolSection:AddButton({
    ["Name"] = "| Destroy Equipped Tool",
    ["Callback"] = function()
        local tool = getEquippedTool()
        if tool then
            local name = tool.Name
            tool:Destroy()
            sendNotification("Destroyed", "Destroyed " .. name)
        else
            sendNotification("Error", "No tool equipped!")
        end
    end
})


--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 34: MISC TAB - ANTI-CHEAT SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local AntiCheatSection = MiscTab:CreateSection({
    ["Name"] = "|Anti-Cheat|",
    ["Side"] = "Right"
})

-- Anti-Void
AntiCheatSection:AddToggle({
    ["Name"] = "| Anti-Void",
    ["Callback"] = function(Value)
        Settings.AntiVoidEnabled = Value
        
        if Value then
            Connections["AntiVoid"] = RunService.Heartbeat:Connect(function()
                if Settings.AntiVoidEnabled then
                    local hrp = getHRP()
                    if hrp and hrp.Position.Y < Settings.AntiVoidHeight then
                        hrp.CFrame = CFrame.new(hrp.Position.X, 50, hrp.Position.Z)
                    end
                end
            end)
        else
            if Connections["AntiVoid"] then
                Connections["AntiVoid"]:Disconnect()
                Connections["AntiVoid"] = nil
            end
        end
    end
})

AntiCheatSection:AddSlider({
    ["Min"] = -500,
    ["Max"] = 0,
    ["Name"] = "Void Height",
    ["Value"] = -100,
    ["Decimals"] = 0,
    ["Callback"] = function(Value)
        Settings.AntiVoidHeight = Value
    end
})

-- Auto Respawn
AntiCheatSection:AddToggle({
    ["Name"] = "| Auto Respawn",
    ["Callback"] = function(Value)
        Settings.AutoRespawnEnabled = Value
    end
})

AntiCheatSection:AddSlider({
    ["Min"] = 0,
    ["Max"] = 10,
    ["Name"] = "Respawn Delay",
    ["Value"] = 1,
    ["Decimals"] = 1,
    ["Callback"] = function(Value)
        Settings.AutoRespawnDelay = Value
    end
})

-- Auto Rejoin on Error
AntiCheatSection:AddToggle({
    ["Name"] = "| Auto Rejoin on Error",
    ["Callback"] = function(Value)
        if Value then
            game:GetService("CoreGui").RobloxPromptGui.promptOverlay.ChildAdded:Connect(function(child)
                if child.Name == "ErrorPrompt" and child:FindFirstChild("MessageArea") then
                    task.wait(2)
                    TeleportService:Teleport(GamePlaceId, LocalPlayer)
                end
            end)
        end
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 35: MISC TAB - FAKE LAG SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local FakeLagSection = MiscTab:CreateSection({
    ["Name"] = "|Fake Lag|",
    ["Side"] = "Right"
})

FakeLagSection:AddToggle({
    ["Name"] = "| Fake Lag",
    ["Callback"] = function(Value)
        Settings.FakeLagEnabled = Value
        
        if Value then
            spawn(function()
                while Settings.FakeLagEnabled do
                    local hrp = getHRP()
                    if hrp then
                        hrp.Anchored = true
                        task.wait(Settings.FakeLagAmount)
                        hrp.Anchored = false
                        task.wait(0.1)
                    else
                        task.wait(0.1)
                    end
                end
            end)
        end
    end
})

FakeLagSection:AddSlider({
    ["Min"] = 0.1,
    ["Max"] = 3,
    ["Name"] = "Lag Amount",
    ["Value"] = 0.5,
    ["Decimals"] = 1,
    ["Callback"] = function(Value)
        Settings.FakeLagAmount = Value
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 36: MISC TAB - PATHFINDING SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local PathfindSection = MiscTab:CreateSection({
    ["Name"] = "|Pathfinding|",
    ["Side"] = "Left"
})

local PathfindTarget = nil
local PathfindRunning = false

PathfindSection:AddTextbox({
    ["Name"] = "Target Player",
    ["Value"] = "",
    ["Callback"] = function(Value)
        PathfindTarget = findPlayer(Value)
        if PathfindTarget then
            sendNotification("Target Set", "Pathfind target: " .. PathfindTarget.Name)
        end
    end
})

PathfindSection:AddButton({
    ["Name"] = "| Start Pathfinding",
    ["Callback"] = function()
        if not PathfindTarget or not PathfindTarget.Character then
            sendNotification("Error", "No valid target!")
            return
        end
        
        PathfindRunning = true
        
        spawn(function()
            while PathfindRunning and PathfindTarget and PathfindTarget.Character do
                local targetHRP = PathfindTarget.Character:FindFirstChild("HumanoidRootPart")
                local myHRP = getHRP()
                local hum = getHumanoid()
                
                if not targetHRP or not myHRP or not hum then break end
                
                local path = PathfindingService:CreatePath({
                    AgentRadius = 2,
                    AgentHeight = 5,
                    AgentCanJump = true,
                    AgentJumpHeight = 10,
                    AgentMaxSlope = 45
                })
                
                local success, err = pcall(function()
                    path:ComputeAsync(myHRP.Position, targetHRP.Position)
                end)
                
                if success and path.Status == Enum.PathStatus.Success then
                    local waypoints = path:GetWaypoints()
                    
                    for _, waypoint in pairs(waypoints) do
                        if not PathfindRunning then break end
                        
                        hum:MoveTo(waypoint.Position)
                        
                        if waypoint.Action == Enum.PathWaypointAction.Jump then
                            hum:ChangeState(Enum.HumanoidStateType.Jumping)
                        end
                        
                        local moveFinished = hum.MoveToFinished:Wait()
                    end
                end
                
                task.wait(0.5)
            end
        end)
        
        sendNotification("Pathfinding", "Started pathfinding to " .. PathfindTarget.Name)
    end
})

PathfindSection:AddButton({
    ["Name"] = "| Stop Pathfinding",
    ["Callback"] = function()
        PathfindRunning = false
        local hum = getHumanoid()
        if hum then
            hum:MoveTo(getHRP().Position)
        end
        sendNotification("Pathfinding", "Stopped pathfinding")
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 37: MISC TAB - BODY MOVER SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local BodyMoverSection = MiscTab:CreateSection({
    ["Name"] = "|Body Mover|",
    ["Side"] = "Left"
})

local BodyForceDirection = "Up"
local BodyForceAmount = 50000

BodyMoverSection:AddDropdown({
    ["Name"] = "Force Direction",
    ["List"] = {"Up", "Down", "Forward", "Backward", "Left", "Right"},
    ["Callback"] = function(Value)
        BodyForceDirection = Value
    end
})

BodyMoverSection:AddSlider({
    ["Min"] = 10000,
    ["Max"] = 1000000,
    ["Name"] = "Force Amount",
    ["Value"] = 50000,
    ["Decimals"] = 0,
    ["Callback"] = function(Value)
        BodyForceAmount = Value
    end
})

BodyMoverSection:AddToggle({
    ["Name"] = "| Apply Body Force",
    ["Callback"] = function(Value)
        local hrp = getHRP()
        if not hrp then return end
        
        if Value then
            local existing = hrp:FindFirstChild("CustomBodyForce")
            if existing then existing:Destroy() end
            
            local bf = Instance.new("BodyForce")
            bf.Name = "CustomBodyForce"
            
            local forceVector = Vector3.new(0, 0, 0)
            
            if BodyForceDirection == "Up" then
                forceVector = Vector3.new(0, BodyForceAmount, 0)
            elseif BodyForceDirection == "Down" then
                forceVector = Vector3.new(0, -BodyForceAmount, 0)
            elseif BodyForceDirection == "Forward" then
                forceVector = Camera.CFrame.LookVector * BodyForceAmount
            elseif BodyForceDirection == "Backward" then
                forceVector = -Camera.CFrame.LookVector * BodyForceAmount
            elseif BodyForceDirection == "Left" then
                forceVector = -Camera.CFrame.RightVector * BodyForceAmount
            elseif BodyForceDirection == "Right" then
                forceVector = Camera.CFrame.RightVector * BodyForceAmount
            end
            
            bf.Force = forceVector
            bf.Parent = hrp
        else
            local existing = hrp:FindFirstChild("CustomBodyForce")
            if existing then existing:Destroy() end
        end
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 38: MISC TAB - TROLL SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local TrollSection = MiscTab:CreateSection({
    ["Name"] = "|Troll|",
    ["Side"] = "Right"
})

local TrollTarget = nil

TrollSection:AddTextbox({
    ["Name"] = "Troll Target",
    ["Value"] = "",
    ["Callback"] = function(Value)
        TrollTarget = findPlayer(Value)
        if TrollTarget then
            sendNotification("Target Set", "Troll target: " .. TrollTarget.Name)
        end
    end
})

-- Copy Player Appearance
TrollSection:AddButton({
    ["Name"] = "| Copy Player Appearance",
    ["Callback"] = function()
        if TrollTarget and TrollTarget.Character and LocalCharacter then
            local theirBodyColors = TrollTarget.Character:FindFirstChild("Body Colors")
            local myBodyColors = LocalCharacter:FindFirstChild("Body Colors")
            
            if theirBodyColors and myBodyColors then
                myBodyColors.HeadColor = theirBodyColors.HeadColor
                myBodyColors.TorsoColor = theirBodyColors.TorsoColor
                myBodyColors.LeftArmColor = theirBodyColors.LeftArmColor
                myBodyColors.RightArmColor = theirBodyColors.RightArmColor
                myBodyColors.LeftLegColor = theirBodyColors.LeftLegColor
                myBodyColors.RightLegColor = theirBodyColors.RightLegColor
                
                sendNotification("Copied", "Copied " .. TrollTarget.Name .. "'s appearance")
            end
        else
            sendNotification("Error", "No valid target!")
        end
    end
})

-- Steal Avatar
TrollSection:AddButton({
    ["Name"] = "| Steal Avatar",
    ["Callback"] = function()
        if TrollTarget then
            pcall(function()
                local desc = Players:GetHumanoidDescriptionFromUserId(TrollTarget.UserId)
                local hum = getHumanoid()
                if hum and desc then
                    hum:ApplyDescription(desc)
                    sendNotification("Stolen", "Stole " .. TrollTarget.Name .. "'s avatar")
                end
            end)
        else
            sendNotification("Error", "No valid target!")
        end
    end
})

-- Annoy Mode
TrollSection:AddToggle({
    ["Name"] = "| Annoy Mode",
    ["Callback"] = function(Value)
        if Value and TrollTarget then
            Connections["AnnoyMode"] = RunService.Heartbeat:Connect(function()
                if TrollTarget and TrollTarget.Character then
                    local theirHRP = TrollTarget.Character:FindFirstChild("HumanoidRootPart")
                    local myHRP = getHRP()
                    
                    if theirHRP and myHRP then
                        myHRP.CFrame = theirHRP.CFrame * CFrame.new(
                            math.random(-5, 5),
                            math.random(-2, 5),
                            math.random(-5, 5)
                        )
                    end
                end
            end)
        else
            if Connections["AnnoyMode"] then
                Connections["AnnoyMode"]:Disconnect()
                Connections["AnnoyMode"] = nil
            end
        end
    end
})

-- Follow Mode
TrollSection:AddToggle({
    ["Name"] = "| Follow Mode",
    ["Callback"] = function(Value)
        if Value and TrollTarget then
            Connections["FollowMode"] = RunService.Heartbeat:Connect(function()
                if TrollTarget and TrollTarget.Character then
                    local theirHRP = TrollTarget.Character:FindFirstChild("HumanoidRootPart")
                    local hum = getHumanoid()
                    
                    if theirHRP and hum then
                        hum:MoveTo(theirHRP.Position)
                    end
                end
            end)
        else
            if Connections["FollowMode"] then
                Connections["FollowMode"]:Disconnect()
                Connections["FollowMode"] = nil
            end
        end
    end
})

-- Mirror Mode
TrollSection:AddToggle({
    ["Name"] = "| Mirror Mode",
    ["Callback"] = function(Value)
        if Value and TrollTarget then
            Connections["MirrorMode"] = RunService.Heartbeat:Connect(function()
                if TrollTarget and TrollTarget.Character then
                    local theirHRP = TrollTarget.Character:FindFirstChild("HumanoidRootPart")
                    local myHRP = getHRP()
                    
                    if theirHRP and myHRP then
                        myHRP.CFrame = theirHRP.CFrame * CFrame.new(0, 0, -3)
                    end
                end
            end)
        else
            if Connections["MirrorMode"] then
                Connections["MirrorMode"]:Disconnect()
                Connections["MirrorMode"] = nil
            end
        end
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 39: MISC TAB - ANIMATION SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local AnimationSection = MiscTab:CreateSection({
    ["Name"] = "|Animations|",
    ["Side"] = "Left"
})

local AnimationId = ""
local AnimationSpeed = 1

AnimationSection:AddTextbox({
    ["Name"] = "Animation ID",
    ["Value"] = "",
    ["Callback"] = function(Value)
        AnimationId = "rbxassetid://" .. Value
    end
})

AnimationSection:AddSlider({
    ["Min"] = 0.1,
    ["Max"] = 5,
    ["Name"] = "Animation Speed",
    ["Value"] = 1,
    ["Decimals"] = 1,
    ["Callback"] = function(Value)
        AnimationSpeed = Value
        if CurrentAnimation then
            CurrentAnimation:AdjustSpeed(Value)
        end
    end
})

AnimationSection:AddButton({
    ["Name"] = "| Play Animation",
    ["Callback"] = function()
        if AnimationId == "" then
            sendNotification("Error", "No animation ID set!")
            return
        end
        
        local hum = getHumanoid()
        if hum then
            local animator = hum:FindFirstChildOfClass("Animator")
            if not animator then
                animator = Instance.new("Animator")
                animator.Parent = hum
            end
            
            local anim = Instance.new("Animation")
            anim.AnimationId = AnimationId
            
            pcall(function()
                CurrentAnimation = animator:LoadAnimation(anim)
                CurrentAnimation:AdjustSpeed(AnimationSpeed)
                CurrentAnimation:Play()
                sendNotification("Animation", "Playing animation")
            end)
        end
    end
})

AnimationSection:AddButton({
    ["Name"] = "| Stop Animation",
    ["Callback"] = function()
        if CurrentAnimation then
            CurrentAnimation:Stop()
            CurrentAnimation = nil
            sendNotification("Animation", "Stopped animation")
        end
    end
})

AnimationSection:AddButton({
    ["Name"] = "| Stop All Animations",
    ["Callback"] = function()
        local hum = getHumanoid()
        if hum then
            local animator = hum:FindFirstChildOfClass("Animator")
            if animator then
                for _, track in pairs(animator:GetPlayingAnimationTracks()) do
                    track:Stop()
                end
                sendNotification("Animation", "Stopped all animations")
            end
        end
    end
})

-- Preset Animations
local PresetAnimations = {
    ["T-Pose"] = "5915713",
    ["Levitate"] = "5917459",
    ["Headless"] = "5915779",
    ["Zombie Walk"] = "5915828",
    ["Ninja Walk"] = "5915791",
    ["Superhero Walk"] = "5915806",
    ["Mage Walk"] = "5915785",
    ["Vampire Walk"] = "5915818",
    ["Werewolf Walk"] = "5915822",
    ["Robot Walk"] = "5915797",
    ["Bubbly Walk"] = "5915762",
    ["Stylish Walk"] = "5915810"
}

AnimationSection:AddDropdown({
    ["Name"] = "Preset Animations",
    ["List"] = (function()
        local list = {}
        for name, _ in pairs(PresetAnimations) do
            table.insert(list, name)
        end
        table.sort(list)
        return list
    end)(),
    ["Callback"] = function(Value)
        AnimationId = "rbxassetid://" .. PresetAnimations[Value]
    end
})


--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 40: SETTINGS TAB - SERVER SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local ServerSection = SettingsTab:CreateSection({
    ["Name"] = "|Server|",
    ["Side"] = "Left"
})

-- Server Hop (GITHUB)
ServerSection:AddButton({
    ["Name"] = "Server Hop",
    ["Callback"] = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Morples/Server-hop/refs/heads/main/Script", true))()
    end
})

-- Rejoin Server
ServerSection:AddButton({
    ["Name"] = "Rejoin Server",
    ["Callback"] = function()
        sendNotification("Rejoining", "Rejoining server in 2 seconds...")
        task.wait(2)
        TeleportService:Teleport(GamePlaceId, LocalPlayer)
    end
})

-- Join Lowest Server
ServerSection:AddButton({
    ["Name"] = "Join Lowest Server",
    ["Callback"] = function()
        pcall(function()
            local servers = HttpService:JSONDecode(
                game:HttpGet("https://games.roblox.com/v1/games/" .. GamePlaceId .. "/servers/Public?sortOrder=Asc&limit=100")
            )
            
            if servers and servers.data then
                local lowestServer = nil
                local lowestPlayers = math.huge
                
                for _, server in pairs(servers.data) do
                    if server.playing < lowestPlayers and server.id ~= GameJobId then
                        lowestPlayers = server.playing
                        lowestServer = server
                    end
                end
                
                if lowestServer then
                    sendNotification("Joining", "Joining server with " .. lowestPlayers .. " players...")
                    TeleportService:TeleportToPlaceInstance(GamePlaceId, lowestServer.id, LocalPlayer)
                else
                    sendNotification("Error", "No available servers found!")
                end
            end
        end)
    end
})

-- Join Highest Server
ServerSection:AddButton({
    ["Name"] = "Join Highest Server",
    ["Callback"] = function()
        pcall(function()
            local servers = HttpService:JSONDecode(
                game:HttpGet("https://games.roblox.com/v1/games/" .. GamePlaceId .. "/servers/Public?sortOrder=Desc&limit=100")
            )
            
            if servers and servers.data and servers.data[1] and servers.data[1].id ~= GameJobId then
                sendNotification("Joining", "Joining server with " .. servers.data[1].playing .. " players...")
                TeleportService:TeleportToPlaceInstance(GamePlaceId, servers.data[1].id, LocalPlayer)
            else
                sendNotification("Error", "No available servers found!")
            end
        end)
    end
})

-- Anti AFK (PASTEBIN)
ServerSection:AddButton({
    ["Name"] = "Anti AFK",
    ["Callback"] = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/DtwLVRdP"))()
        sendNotification("Anti AFK", "Anti AFK enabled!")
    end
})

-- Custom Anti-AFK
ServerSection:AddToggle({
    ["Name"] = "| Custom Anti-AFK",
    ["Callback"] = function(Value)
        Settings.AntiAFKEnabled = Value
        
        if Value then
            -- Method 1: Virtual User
            Connections["AntiAFK1"] = LocalPlayer.Idled:Connect(function()
                pcall(function()
                    VirtualUser:CaptureController()
                    VirtualUser:ClickButton2(Vector2.new())
                end)
            end)
            
            -- Method 2: Periodic Jump
            spawn(function()
                while Settings.AntiAFKEnabled do
                    pcall(function()
                        local hum = getHumanoid()
                        if hum then
                            hum:ChangeState(Enum.HumanoidStateType.Jumping)
                        end
                    end)
                    task.wait(300) -- Every 5 minutes
                end
            end)
            
            sendNotification("Anti-AFK", "Custom Anti-AFK enabled!")
        else
            if Connections["AntiAFK1"] then
                Connections["AntiAFK1"]:Disconnect()
                Connections["AntiAFK1"] = nil
            end
        end
    end
})

-- Suicide
ServerSection:AddButton({
    ["Name"] = "Suicide",
    ["Callback"] = function()
        local hum = getHumanoid()
        if hum then
            hum.Health = 0
        end
    end
})

-- HideName (PASTEBIN)
ServerSection:AddButton({
    ["Name"] = "HideName",
    ["Callback"] = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/iPcPNt23"))()
        sendNotification("Hide Name", "Name hidden!")
    end
})

-- Enable Reset Button (PASTEBIN)
ServerSection:AddButton({
    ["Name"] = "Enable Reset Button",
    ["Callback"] = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/pvNpdimg"))()
        sendNotification("Reset Button", "Reset button enabled!")
    end
})

-- Low GFX (PASTEBIN)
ServerSection:AddButton({
    ["Name"] = "Low Gfx",
    ["Callback"] = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/SS4E3tDQ"))()
        sendNotification("Low GFX", "Graphics reduced!")
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 41: SETTINGS TAB - DEBUG SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local DebugSection = SettingsTab:CreateSection({
    ["Name"] = "|Debug|",
    ["Side"] = "Left"
})

-- FPS Counter
DebugLabels.FPS = Drawing.new("Text")
DebugLabels.FPS.Visible = false
DebugLabels.FPS.Color = Color3.fromRGB(255, 255, 0)
DebugLabels.FPS.Size = 16
DebugLabels.FPS.Position = Vector2.new(10, 10)
DebugLabels.FPS.Outline = true
DebugLabels.FPS.OutlineColor = Color3.new(0, 0, 0)
DebugLabels.FPS.Font = Drawing.Fonts.UI

-- Ping Counter
DebugLabels.Ping = Drawing.new("Text")
DebugLabels.Ping.Visible = false
DebugLabels.Ping.Color = Color3.fromRGB(255, 255, 0)
DebugLabels.Ping.Size = 16
DebugLabels.Ping.Position = Vector2.new(10, 30)
DebugLabels.Ping.Outline = true
DebugLabels.Ping.OutlineColor = Color3.new(0, 0, 0)
DebugLabels.Ping.Font = Drawing.Fonts.UI

-- Position Display
DebugLabels.Position = Drawing.new("Text")
DebugLabels.Position.Visible = false
DebugLabels.Position.Color = Color3.fromRGB(255, 255, 0)
DebugLabels.Position.Size = 16
DebugLabels.Position.Position = Vector2.new(10, 50)
DebugLabels.Position.Outline = true
DebugLabels.Position.OutlineColor = Color3.new(0, 0, 0)
DebugLabels.Position.Font = Drawing.Fonts.UI

-- Velocity Display
DebugLabels.Velocity = Drawing.new("Text")
DebugLabels.Velocity.Visible = false
DebugLabels.Velocity.Color = Color3.fromRGB(255, 255, 0)
DebugLabels.Velocity.Size = 16
DebugLabels.Velocity.Position = Vector2.new(10, 70)
DebugLabels.Velocity.Outline = true
DebugLabels.Velocity.OutlineColor = Color3.new(0, 0, 0)
DebugLabels.Velocity.Font = Drawing.Fonts.UI

-- FPS Counter Toggle
DebugSection:AddToggle({
    ["Name"] = "| FPS Counter",
    ["Callback"] = function(Value)
        Settings.FPSEnabled = Value
        DebugLabels.FPS.Visible = Value
    end
})

-- Ping Counter Toggle
DebugSection:AddToggle({
    ["Name"] = "| Ping Display",
    ["Callback"] = function(Value)
        Settings.PingEnabled = Value
        DebugLabels.Ping.Visible = Value
    end
})

-- Position Display Toggle
DebugSection:AddToggle({
    ["Name"] = "| Position Display",
    ["Callback"] = function(Value)
        Settings.PositionEnabled = Value
        DebugLabels.Position.Visible = Value
    end
})

-- Velocity Display Toggle
DebugSection:AddToggle({
    ["Name"] = "| Velocity Display",
    ["Callback"] = function(Value)
        Settings.VelocityEnabled = Value
        DebugLabels.Velocity.Visible = Value
    end
})

-- Debug Update Loop
local lastFrameTime = tick()
local frameCount = 0
local fps = 0

Connections["DebugUpdate"] = RunService.RenderStepped:Connect(function()
    -- FPS Calculation
    frameCount = frameCount + 1
    local currentTime = tick()
    if currentTime - lastFrameTime >= 1 then
        fps = frameCount
        frameCount = 0
        lastFrameTime = currentTime
    end
    
    -- Update FPS Display
    if Settings.FPSEnabled then
        DebugLabels.FPS.Text = "FPS: " .. fps
    end
    
    -- Update Ping Display
    if Settings.PingEnabled then
        local ping = math.floor(LocalPlayer:GetNetworkPing() * 1000)
        DebugLabels.Ping.Text = "Ping: " .. ping .. "ms"
    end
    
    -- Update Position Display
    if Settings.PositionEnabled then
        local hrp = getHRP()
        if hrp then
            local pos = hrp.Position
            DebugLabels.Position.Text = string.format("Pos: %.1f, %.1f, %.1f", pos.X, pos.Y, pos.Z)
        end
    end
    
    -- Update Velocity Display
    if Settings.VelocityEnabled then
        local hrp = getHRP()
        if hrp then
            local vel = hrp.Velocity.Magnitude
            DebugLabels.Velocity.Text = string.format("Velocity: %.1f", vel)
        end
    end
end)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 42: SETTINGS TAB - GAME INFO SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local GameInfoSection = SettingsTab:CreateSection({
    ["Name"] = "|Game Info|",
    ["Side"] = "Right"
})

-- Print All RemoteEvents
GameInfoSection:AddButton({
    ["Name"] = "| Print All RemoteEvents",
    ["Callback"] = function()
        local count = 0
        print("=== REMOTE EVENTS ===")
        for _, v in pairs(ReplicatedStorage:GetDescendants()) do
            if v:IsA("RemoteEvent") then
                print("RemoteEvent: " .. v:GetFullName())
                count = count + 1
            end
        end
        print("=====================")
        sendNotification("RemoteEvents", "Found " .. count .. " RemoteEvents (check output)")
    end
})

-- Print All RemoteFunctions
GameInfoSection:AddButton({
    ["Name"] = "| Print All RemoteFunctions",
    ["Callback"] = function()
        local count = 0
        print("=== REMOTE FUNCTIONS ===")
        for _, v in pairs(ReplicatedStorage:GetDescendants()) do
            if v:IsA("RemoteFunction") then
                print("RemoteFunction: " .. v:GetFullName())
                count = count + 1
            end
        end
        print("========================")
        sendNotification("RemoteFunctions", "Found " .. count .. " RemoteFunctions (check output)")
    end
})

-- Print All Tools in Workspace
GameInfoSection:AddButton({
    ["Name"] = "| Print All Tools",
    ["Callback"] = function()
        local count = 0
        print("=== TOOLS IN WORKSPACE ===")
        for _, v in pairs(Workspace:GetDescendants()) do
            if v:IsA("Tool") then
                print("Tool: " .. v.Name .. " at " .. v:GetFullName())
                count = count + 1
            end
        end
        print("==========================")
        sendNotification("Tools", "Found " .. count .. " tools (check output)")
    end
})

-- Print Player List
GameInfoSection:AddButton({
    ["Name"] = "| Print Player List",
    ["Callback"] = function()
        print("=== PLAYER LIST ===")
        for i, player in pairs(Players:GetPlayers()) do
            local status = player == LocalPlayer and "(YOU)" or ""
            local team = player.Team and player.Team.Name or "No Team"
            print(string.format("%d. %s (%s) - Team: %s %s", i, player.Name, player.DisplayName, team, status))
        end
        print("===================")
        sendNotification("Players", "Printed " .. #Players:GetPlayers() .. " players")
    end
})

-- Copy Game Link
GameInfoSection:AddButton({
    ["Name"] = "| Copy Game Link",
    ["Callback"] = function()
        local link = "https://www.roblox.com/games/" .. GamePlaceId
        copyToClipboard(link)
    end
})

-- Copy Server ID
GameInfoSection:AddButton({
    ["Name"] = "| Copy Server ID",
    ["Callback"] = function()
        copyToClipboard(GameJobId)
    end
})

-- Show My Stats
GameInfoSection:AddButton({
    ["Name"] = "| Show My Stats",
    ["Callback"] = function()
        local hum = getHumanoid()
        local hrp = getHRP()
        
        if hum and hrp then
            print("=== YOUR STATS ===")
            print("Health: " .. math.floor(hum.Health) .. "/" .. hum.MaxHealth)
            print("WalkSpeed: " .. hum.WalkSpeed)
            print("JumpPower: " .. hum.JumpPower)
            print("Position: " .. tostring(hrp.Position))
            print("Velocity: " .. hrp.Velocity.Magnitude)
            print("==================")
            sendNotification("Stats", "Your stats printed to output")
        end
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 43: SETTINGS TAB - PLAYER INFO SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local PlayerInfoSection = SettingsTab:CreateSection({
    ["Name"] = "|Player Info|",
    ["Side"] = "Right"
})

local InfoTarget = nil

PlayerInfoSection:AddTextbox({
    ["Name"] = "Target Name",
    ["Value"] = "",
    ["Callback"] = function(Value)
        InfoTarget = findPlayer(Value)
        if InfoTarget then
            sendNotification("Target", "Info target: " .. InfoTarget.Name)
        end
    end
})

PlayerInfoSection:AddButton({
    ["Name"] = "| Show Target Stats",
    ["Callback"] = function()
        if InfoTarget and InfoTarget.Character then
            local hum = InfoTarget.Character:FindFirstChildOfClass("Humanoid")
            local hrp = InfoTarget.Character:FindFirstChild("HumanoidRootPart")
            
            if hum and hrp then
                print("=== " .. InfoTarget.Name .. " STATS ===")
                print("Display Name: " .. InfoTarget.DisplayName)
                print("User ID: " .. InfoTarget.UserId)
                print("Account Age: " .. InfoTarget.AccountAge .. " days")
                print("Health: " .. math.floor(hum.Health) .. "/" .. hum.MaxHealth)
                print("WalkSpeed: " .. hum.WalkSpeed)
                print("JumpPower: " .. hum.JumpPower)
                print("Position: " .. tostring(hrp.Position))
                
                local myHRP = getHRP()
                if myHRP then
                    local dist = (hrp.Position - myHRP.Position).Magnitude
                    print("Distance from you: " .. math.floor(dist) .. " studs")
                end
                
                -- List tools
                print("--- Tools ---")
                local toolCount = 0
                if InfoTarget.Character then
                    for _, item in pairs(InfoTarget.Character:GetChildren()) do
                        if item:IsA("Tool") then
                            print("  [Equipped] " .. item.Name)
                            toolCount = toolCount + 1
                        end
                    end
                end
                local backpack = InfoTarget:FindFirstChild("Backpack")
                if backpack then
                    for _, item in pairs(backpack:GetChildren()) do
                        if item:IsA("Tool") then
                            print("  [Backpack] " .. item.Name)
                            toolCount = toolCount + 1
                        end
                    end
                end
                print("Total tools: " .. toolCount)
                print("========================")
                
                sendNotification("Stats", InfoTarget.Name .. "'s stats printed to output")
            end
        else
            sendNotification("Error", "No valid target!")
        end
    end
})

PlayerInfoSection:AddButton({
    ["Name"] = "| Show All Distances",
    ["Callback"] = function()
        local myHRP = getHRP()
        if not myHRP then return end
        
        print("=== PLAYER DISTANCES ===")
        local distances = {}
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local dist = (hrp.Position - myHRP.Position).Magnitude
                    table.insert(distances, {player = player.Name, distance = dist})
                end
            end
        end
        
        table.sort(distances, function(a, b) return a.distance < b.distance end)
        
        for i, data in pairs(distances) do
            print(string.format("%d. %s - %.1f studs", i, data.player, data.distance))
        end
        print("========================")
        
        sendNotification("Distances", "Printed " .. #distances .. " player distances")
    end
})

PlayerInfoSection:AddButton({
    ["Name"] = "| Show Closest Player",
    ["Callback"] = function()
        local closest, dist = getClosestPlayer(math.huge, false, false, false)
        if closest then
            sendNotification("Closest", closest.Name .. " is " .. math.floor(dist) .. " studs away")
        else
            sendNotification("Error", "No other players found!")
        end
    end
})


--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 44: SETTINGS TAB - SCRIPT CONTROLS SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local ScriptControlSection = SettingsTab:CreateSection({
    ["Name"] = "|Script Controls|",
    ["Side"] = "Right"
})

-- Destroy All ESP
ScriptControlSection:AddButton({
    ["Name"] = "| Destroy All ESP",
    ["Callback"] = function()
        -- Destroy Drawing ESP
        for player, esp in pairs(ESPObjects) do
            removeESPForPlayer(player)
        end
        ESPObjects = {}
        
        -- Destroy Highlight ESP
        for _, player in pairs(Players:GetPlayers()) do
            if player.Character then
                local highlight = player.Character:FindFirstChild("ESPHighlight")
                if highlight then highlight:Destroy() end
            end
        end
        
        -- Destroy Chams
        if ChamsFolder then
            ChamsFolder:ClearAllChildren()
        end
        
        -- Reset settings
        Settings.ESPBoxEnabled = false
        Settings.ESPNameEnabled = false
        Settings.ESPHealthEnabled = false
        Settings.ESPDistanceEnabled = false
        Settings.ESPTracerEnabled = false
        Settings.ESPSkeletonEnabled = false
        Settings.ESPHeadDotEnabled = false
        Settings.ESPWeaponEnabled = false
        Settings.HighlightEnabled = false
        Settings.ChamsEnabled = false
        
        sendNotification("ESP", "All ESP destroyed!")
    end
})

-- Destroy Script
ScriptControlSection:AddButton({
    ["Name"] = "| Destroy Script",
    ["Callback"] = function()
        cleanUp()
        
        -- Destroy UI
        if MainWindow then
            pcall(function()
                MainWindow:Destroy()
            end)
        end
        
        sendNotification("Script", "Script destroyed!")
    end
})

-- Reset All Settings
ScriptControlSection:AddButton({
    ["Name"] = "| Reset All Settings",
    ["Callback"] = function()
        -- Reset all settings to default
        Settings.WalkSpeed = 16
        Settings.JumpPower = 50
        Settings.Gravity = 196.2
        Settings.HipHeight = 2
        Settings.FOV = 70
        Settings.FlyEnabled = false
        Settings.NoclipEnabled = false
        Settings.InvisibleEnabled = false
        Settings.GodModeEnabled = false
        Settings.InfiniteJumpEnabled = false
        Settings.AimbotEnabled = false
        Settings.AimbotFOV = 150
        Settings.AimbotSmoothness = 0.5
        
        -- Apply defaults
        local hum = getHumanoid()
        if hum then
            hum.WalkSpeed = 16
            hum.JumpPower = 50
        end
        Camera.FieldOfView = 70
        Workspace.Gravity = 196.2
        
        sendNotification("Settings", "All settings reset to default!")
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 45: KEYBIND SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

-- Keybind Handler
Connections["Keybinds"] = UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    -- V = Toggle Fly
    if input.KeyCode == Enum.KeyCode.V then
        -- Fly is handled by pastebin
    end
    
    -- N = Toggle Noclip
    if input.KeyCode == Enum.KeyCode.N then
        Settings.NoclipEnabled = not Settings.NoclipEnabled
        sendNotification("Noclip", Settings.NoclipEnabled and "Enabled" or "Disabled")
    end
    
    -- T = Forward Teleport (handled by pastebin)
    
    -- X = Invisible (handled by pastebin)
    
    -- E = TP to Mouse (if enabled via toggle)
    
    -- L = Stop TP Loops
    if input.KeyCode == Enum.KeyCode.L then
        Settings.TPLoopEnabled = false
        Settings.FlingEnabled = false
        Settings.AnnoyEnabled = false
        Settings.OrbitEnabled = false
        PathfindRunning = false
        sendNotification("Loops", "All loops stopped!")
    end
    
    -- Space = Infinite Jump (if enabled)
    if input.KeyCode == Enum.KeyCode.Space then
        if Settings.InfiniteJumpEnabled then
            local hum = getHumanoid()
            if hum then
                hum:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end
    end
    
    -- RShift = Toggle UI (handled by library)
end)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 46: CUSTOM FLY SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local function startCustomFly()
    local hrp = getHRP()
    local hum = getHumanoid()
    if not hrp or not hum then return end
    
    -- Clean up existing
    if FlyBodyVelocity then FlyBodyVelocity:Destroy() end
    if FlyBodyGyro then FlyBodyGyro:Destroy() end
    
    -- Create body movers
    FlyBodyVelocity = Instance.new("BodyVelocity")
    FlyBodyVelocity.Name = "FlyBV"
    FlyBodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    FlyBodyVelocity.Velocity = Vector3.new(0, 0, 0)
    FlyBodyVelocity.Parent = hrp
    
    FlyBodyGyro = Instance.new("BodyGyro")
    FlyBodyGyro.Name = "FlyBG"
    FlyBodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    FlyBodyGyro.P = 9e4
    FlyBodyGyro.Parent = hrp
    
    hum.PlatformStand = true
    
    -- Fly control loop
    Connections["FlyControl"] = RunService.RenderStepped:Connect(function()
        if Settings.FlyEnabled and FlyBodyVelocity and FlyBodyGyro then
            FlyBodyGyro.CFrame = Camera.CFrame
            
            local velocity = Vector3.new(0, 0, 0)
            
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                velocity = velocity + Camera.CFrame.LookVector * Settings.FlySpeed
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                velocity = velocity - Camera.CFrame.LookVector * Settings.FlySpeed
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                velocity = velocity - Camera.CFrame.RightVector * Settings.FlySpeed
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                velocity = velocity + Camera.CFrame.RightVector * Settings.FlySpeed
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                velocity = velocity + Vector3.new(0, Settings.FlySpeed, 0)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
                velocity = velocity - Vector3.new(0, Settings.FlySpeed, 0)
            end
            
            FlyBodyVelocity.Velocity = velocity
        end
    end)
end

local function stopCustomFly()
    if FlyBodyVelocity then
        FlyBodyVelocity:Destroy()
        FlyBodyVelocity = nil
    end
    
    if FlyBodyGyro then
        FlyBodyGyro:Destroy()
        FlyBodyGyro = nil
    end
    
    if Connections["FlyControl"] then
        Connections["FlyControl"]:Disconnect()
        Connections["FlyControl"] = nil
    end
    
    local hum = getHumanoid()
    if hum then
        hum.PlatformStand = false
    end
end

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 47: OFF-SCREEN ARROWS SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local ArrowSize = 20

local function createArrowForPlayer(player)
    if player == LocalPlayer then return end
    
    ArrowDrawings[player] = Drawing.new("Triangle")
    ArrowDrawings[player].Visible = false
    ArrowDrawings[player].Color = Color3.fromRGB(255, 0, 0)
    ArrowDrawings[player].Filled = true
    ArrowDrawings[player].Thickness = 2
end

local function updateOffScreenArrows()
    if not Settings.ESPArrowsEnabled then
        for _, arrow in pairs(ArrowDrawings) do
            arrow.Visible = false
        end
        return
    end
    
    local myHRP = getHRP()
    if not myHRP then return end
    
    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    
    for player, arrow in pairs(ArrowDrawings) do
        if player and player.Parent and player.Character then
            local theirHRP = player.Character:FindFirstChild("HumanoidRootPart")
            if theirHRP then
                local screenPos, onScreen = Camera:WorldToScreenPoint(theirHRP.Position)
                
                if not onScreen then
                    arrow.Visible = true
                    
                    -- Calculate angle to player
                    local direction = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Unit
                    local edgeDistance = math.min(Camera.ViewportSize.X / 2 - 50, Camera.ViewportSize.Y / 2 - 50)
                    local arrowPos = screenCenter + direction * edgeDistance
                    
                    -- Calculate arrow rotation
                    local angle = math.atan2(direction.Y, direction.X)
                    
                    -- Calculate triangle points
                    local point1 = arrowPos + Vector2.new(
                        math.cos(angle) * ArrowSize,
                        math.sin(angle) * ArrowSize
                    )
                    local point2 = arrowPos + Vector2.new(
                        math.cos(angle + math.rad(140)) * ArrowSize * 0.7,
                        math.sin(angle + math.rad(140)) * ArrowSize * 0.7
                    )
                    local point3 = arrowPos + Vector2.new(
                        math.cos(angle - math.rad(140)) * ArrowSize * 0.7,
                        math.sin(angle - math.rad(140)) * ArrowSize * 0.7
                    )
                    
                    arrow.PointA = point1
                    arrow.PointB = point2
                    arrow.PointC = point3
                else
                    arrow.Visible = false
                end
            else
                arrow.Visible = false
            end
        else
            arrow.Visible = false
        end
    end
end

-- Initialize arrows for existing players
for _, player in pairs(Players:GetPlayers()) do
    createArrowForPlayer(player)
end

Players.PlayerAdded:Connect(createArrowForPlayer)
Players.PlayerRemoving:Connect(function(player)
    if ArrowDrawings[player] then
        ArrowDrawings[player]:Remove()
        ArrowDrawings[player] = nil
    end
end)

-- Arrow update loop
Connections["ArrowUpdate"] = RunService.RenderStepped:Connect(updateOffScreenArrows)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 48: INVENTORY VIEWER SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local function createInventoryGui(player)
    -- Remove existing GUI
    local existingGui = LocalPlayer.PlayerGui:FindFirstChild("InventoryViewerGui")
    if existingGui then existingGui:Destroy() end
    
    -- Create new GUI
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "InventoryViewerGui"
    ScreenGui.Parent = LocalPlayer.PlayerGui
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    ScreenGui.ResetOnSpawn = false
    
    -- Main frame
    local MainFrame = Instance.new("Frame")
    MainFrame.Name = "MainFrame"
    MainFrame.Parent = ScreenGui
    MainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    MainFrame.BorderColor3 = Color3.fromRGB(0, 0, 0)
    MainFrame.BorderSizePixel = 2
    MainFrame.Position = UDim2.new(1, -270, 0, 20)
    MainFrame.Size = UDim2.new(0, 250, 0, 300)
    MainFrame.Active = true
    MainFrame.Draggable = true
    
    -- Title
    local TitleLabel = Instance.new("TextLabel")
    TitleLabel.Name = "Title"
    TitleLabel.Parent = MainFrame
    TitleLabel.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    TitleLabel.BorderSizePixel = 0
    TitleLabel.Size = UDim2.new(1, 0, 0, 30)
    TitleLabel.Font = Enum.Font.SourceSansBold
    TitleLabel.Text = "Inventory: " .. player.Name
    TitleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    TitleLabel.TextSize = 16
    
    -- Close button
    local CloseButton = Instance.new("TextButton")
    CloseButton.Name = "Close"
    CloseButton.Parent = TitleLabel
    CloseButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    CloseButton.BorderSizePixel = 0
    CloseButton.Position = UDim2.new(1, -25, 0, 2)
    CloseButton.Size = UDim2.new(0, 23, 0, 23)
    CloseButton.Font = Enum.Font.SourceSansBold
    CloseButton.Text = "X"
    CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    CloseButton.TextSize = 14
    CloseButton.MouseButton1Click:Connect(function()
        ScreenGui:Destroy()
    end)
    
    -- Scrolling frame
    local ScrollFrame = Instance.new("ScrollingFrame")
    ScrollFrame.Name = "Items"
    ScrollFrame.Parent = MainFrame
    ScrollFrame.BackgroundTransparency = 1
    ScrollFrame.Position = UDim2.new(0, 5, 0, 35)
    ScrollFrame.Size = UDim2.new(1, -10, 1, -40)
    ScrollFrame.ScrollBarThickness = 8
    ScrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
    
    -- List layout
    local ListLayout = Instance.new("UIListLayout")
    ListLayout.Parent = ScrollFrame
    ListLayout.Padding = UDim.new(0, 5)
    ListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    
    -- Add items
    local function addItem(name, equipped)
        local ItemFrame = Instance.new("Frame")
        ItemFrame.Size = UDim2.new(1, -10, 0, 25)
        ItemFrame.BackgroundColor3 = equipped and Color3.fromRGB(60, 80, 60) or Color3.fromRGB(50, 50, 50)
        ItemFrame.BorderSizePixel = 0
        ItemFrame.Parent = ScrollFrame
        
        local ItemLabel = Instance.new("TextLabel")
        ItemLabel.Parent = ItemFrame
        ItemLabel.BackgroundTransparency = 1
        ItemLabel.Size = UDim2.new(1, -10, 1, 0)
        ItemLabel.Position = UDim2.new(0, 5, 0, 0)
        ItemLabel.Font = Enum.Font.SourceSans
        ItemLabel.Text = (equipped and "[E] " or "") .. name
        ItemLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        ItemLabel.TextSize = 14
        ItemLabel.TextXAlignment = Enum.TextXAlignment.Left
        
        return ItemFrame
    end
    
    local itemCount = 0
    
    -- Character items (equipped)
    if player.Character then
        for _, item in pairs(player.Character:GetChildren()) do
            if item:IsA("Tool") then
                addItem(item.Name, true)
                itemCount = itemCount + 1
            end
        end
    end
    
    -- Backpack items
    local backpack = player:FindFirstChild("Backpack")
    if backpack then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                addItem(item.Name, false)
                itemCount = itemCount + 1
            end
        end
    end
    
    -- Update canvas size
    ScrollFrame.CanvasSize = UDim2.new(0, 0, 0, itemCount * 30)
    
    -- No items message
    if itemCount == 0 then
        local NoItemsLabel = Instance.new("TextLabel")
        NoItemsLabel.Parent = ScrollFrame
        NoItemsLabel.BackgroundTransparency = 1
        NoItemsLabel.Size = UDim2.new(1, 0, 0, 30)
        NoItemsLabel.Font = Enum.Font.SourceSans
        NoItemsLabel.Text = "No items in inventory"
        NoItemsLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
        NoItemsLabel.TextSize = 14
    end
    
    return ScreenGui
end

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 49: EXTENDED GUN MOD SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local function applyGunMods(tool)
    if not tool or not tool:IsA("Tool") then return end
    
    for _, v in pairs(tool:GetDescendants()) do
        if v:IsA("NumberValue") then
            local name = string.lower(v.Name)
            
            -- Infinite Ammo
            if Settings.InfiniteAmmoEnabled then
                if string.find(name, "ammo") or string.find(name, "mag") or string.find(name, "bullet") or string.find(name, "clip") then
                    v.Value = math.huge
                end
            end
            
            -- Rapid Fire
            if Settings.RapidFireEnabled then
                if string.find(name, "fire") or string.find(name, "rate") or string.find(name, "cooldown") or string.find(name, "delay") then
                    v.Value = Settings.RapidFireRate
                end
            end
            
            -- No Recoil
            if Settings.NoRecoilEnabled then
                if string.find(name, "recoil") or string.find(name, "kick") then
                    v.Value = 0
                end
            end
            
            -- No Spread
            if Settings.NoSpreadEnabled then
                if string.find(name, "spread") or string.find(name, "accuracy") or string.find(name, "bloom") then
                    v.Value = 0
                end
            end
            
            -- Quick Reload
            if Settings.QuickReloadEnabled then
                if string.find(name, "reload") then
                    v.Value = 0.1
                end
            end
            
            -- Infinite Range
            if Settings.InfiniteRangeEnabled then
                if string.find(name, "range") or string.find(name, "distance") then
                    v.Value = 99999
                end
            end
        end
    end
end

-- Apply gun mods on tool equip
Connections["GunModOnEquip"] = LocalPlayer.CharacterAdded:Connect(function(char)
    char.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            task.wait(0.1)
            applyGunMods(child)
        end
    end)
end)

-- Apply to currently equipped
if LocalCharacter then
    for _, tool in pairs(LocalCharacter:GetChildren()) do
        if tool:IsA("Tool") then
            applyGunMods(tool)
        end
    end
end


--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 50: EXTENDED TELEPORT LOCATIONS
═══════════════════════════════════════════════════════════════════════════ ]]--

-- Extended location data for Bruno | South Bronx
local ExtendedLocations = {
    -- Main Locations
    {Name = "Spawn Point 1", Position = Vector3.new(0, 5, 0)},
    {Name = "Spawn Point 2", Position = Vector3.new(50, 5, 50)},
    {Name = "Spawn Point 3", Position = Vector3.new(-50, 5, -50)},
    
    -- Buildings
    {Name = "Gun Store", Position = Vector3.new(100, 5, 100)},
    {Name = "Bank Main", Position = Vector3.new(-100, 5, 100)},
    {Name = "Bank Vault", Position = Vector3.new(-110, -10, 110)},
    {Name = "Hospital", Position = Vector3.new(100, 5, -100)},
    {Name = "Hospital Roof", Position = Vector3.new(100, 50, -100)},
    {Name = "Police Station", Position = Vector3.new(-100, 5, -100)},
    {Name = "Police Armory", Position = Vector3.new(-110, 5, -110)},
    {Name = "Gas Station", Position = Vector3.new(200, 5, 0)},
    {Name = "Apartments 1", Position = Vector3.new(0, 5, 200)},
    {Name = "Apartments 2", Position = Vector3.new(50, 5, 200)},
    {Name = "Apartments Roof", Position = Vector3.new(0, 80, 200)},
    {Name = "Corner Store", Position = Vector3.new(-200, 5, 0)},
    {Name = "Warehouse", Position = Vector3.new(0, 5, -200)},
    {Name = "Warehouse Interior", Position = Vector3.new(0, 5, -210)},
    
    -- Streets & Areas
    {Name = "Main Street", Position = Vector3.new(0, 5, 0)},
    {Name = "Alley 1", Position = Vector3.new(150, 5, 150)},
    {Name = "Alley 2", Position = Vector3.new(-150, 5, 150)},
    {Name = "Parking Lot", Position = Vector3.new(150, 5, -150)},
    {Name = "Basketball Court", Position = Vector3.new(-150, 5, -150)},
    {Name = "Park", Position = Vector3.new(250, 5, 250)},
    {Name = "Bridge", Position = Vector3.new(300, 30, 0)},
    {Name = "Under Bridge", Position = Vector3.new(300, 5, 0)},
    
    -- Underground
    {Name = "Subway Entrance", Position = Vector3.new(50, 5, 50)},
    {Name = "Subway Platform", Position = Vector3.new(50, -20, 50)},
    {Name = "Sewer", Position = Vector3.new(-50, -15, -50)},
    
    -- Rooftops
    {Name = "Rooftop 1", Position = Vector3.new(-150, 50, 150)},
    {Name = "Rooftop 2", Position = Vector3.new(150, 60, 150)},
    {Name = "Rooftop 3", Position = Vector3.new(-150, 40, -150)},
    {Name = "Tallest Building", Position = Vector3.new(0, 100, 0)},
    
    -- ATMs
    {Name = "ATM 1 - Bank", Position = Vector3.new(-90, 5, 95)},
    {Name = "ATM 2 - Store", Position = Vector3.new(-195, 5, 5)},
    {Name = "ATM 3 - Gas", Position = Vector3.new(195, 5, 5)},
    {Name = "ATM 4 - Hospital", Position = Vector3.new(95, 5, -95)},
    
    -- Hidden Spots
    {Name = "Secret Room 1", Position = Vector3.new(75, -5, 75)},
    {Name = "Secret Room 2", Position = Vector3.new(-75, -5, -75)},
    {Name = "Behind Bank", Position = Vector3.new(-120, 5, 120)},
    {Name = "Behind Police", Position = Vector3.new(-120, 5, -120)}
}

-- Function to teleport to extended location
local function teleportToLocation(locationName)
    for _, loc in pairs(ExtendedLocations) do
        if loc.Name == locationName then
            local hrp = getHRP()
            if hrp then
                hrp.CFrame = CFrame.new(loc.Position)
                sendNotification("Teleported", "Teleported to " .. locationName)
                return true
            end
        end
    end
    return false
end

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 51: ESP COLOR SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local ESPColorPresets = {
    ["Red"] = Color3.fromRGB(255, 0, 0),
    ["Green"] = Color3.fromRGB(0, 255, 0),
    ["Blue"] = Color3.fromRGB(0, 0, 255),
    ["Yellow"] = Color3.fromRGB(255, 255, 0),
    ["Purple"] = Color3.fromRGB(128, 0, 255),
    ["Orange"] = Color3.fromRGB(255, 128, 0),
    ["Pink"] = Color3.fromRGB(255, 0, 255),
    ["Cyan"] = Color3.fromRGB(0, 255, 255),
    ["White"] = Color3.fromRGB(255, 255, 255),
    ["Black"] = Color3.fromRGB(0, 0, 0),
    ["Gray"] = Color3.fromRGB(128, 128, 128),
    ["Lime"] = Color3.fromRGB(128, 255, 0),
    ["Aqua"] = Color3.fromRGB(0, 255, 128),
    ["Gold"] = Color3.fromRGB(255, 215, 0),
    ["Silver"] = Color3.fromRGB(192, 192, 192),
    ["Rainbow"] = nil -- Special case
}

local RainbowHue = 0

-- Rainbow color update
Connections["RainbowColor"] = RunService.RenderStepped:Connect(function()
    RainbowHue = (RainbowHue + 0.001) % 1
end)

local function getRainbowColor()
    return Color3.fromHSV(RainbowHue, 1, 1)
end

local function setESPColor(colorName)
    if colorName == "Rainbow" then
        -- Rainbow mode handled in update loop
        Settings.ESPRainbowMode = true
    else
        Settings.ESPRainbowMode = false
        local color = ESPColorPresets[colorName] or Color3.fromRGB(255, 0, 0)
        Settings.ESPBoxColor = color
        Settings.ESPNameColor = color
        Settings.ESPTracerColor = color
        Settings.ESPSkeletonColor = color
    end
end

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 52: NOTIFICATION SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local NotificationQueue = {}
local MaxNotifications = 5
local NotificationDuration = 3

local NotificationContainer = Drawing.new("Square")
NotificationContainer.Visible = false

local function createNotificationDrawing(title, text, duration)
    local yOffset = #NotificationQueue * 70
    
    local notification = {
        Background = Drawing.new("Square"),
        Title = Drawing.new("Text"),
        Text = Drawing.new("Text"),
        StartTime = tick(),
        Duration = duration or NotificationDuration
    }
    
    -- Background
    notification.Background.Visible = true
    notification.Background.Position = Vector2.new(Camera.ViewportSize.X - 310, 10 + yOffset)
    notification.Background.Size = Vector2.new(300, 60)
    notification.Background.Color = Color3.fromRGB(30, 30, 30)
    notification.Background.Filled = true
    notification.Background.Transparency = 0.9
    
    -- Title
    notification.Title.Visible = true
    notification.Title.Position = Vector2.new(Camera.ViewportSize.X - 305, 15 + yOffset)
    notification.Title.Text = title or "Bruno"
    notification.Title.Color = Color3.fromRGB(255, 200, 0)
    notification.Title.Size = 18
    notification.Title.Font = Drawing.Fonts.UI
    notification.Title.Outline = true
    notification.Title.OutlineColor = Color3.new(0, 0, 0)
    
    -- Text
    notification.Text.Visible = true
    notification.Text.Position = Vector2.new(Camera.ViewportSize.X - 305, 38 + yOffset)
    notification.Text.Text = text or ""
    notification.Text.Color = Color3.fromRGB(255, 255, 255)
    notification.Text.Size = 14
    notification.Text.Font = Drawing.Fonts.UI
    notification.Text.Outline = true
    notification.Text.OutlineColor = Color3.new(0, 0, 0)
    
    table.insert(NotificationQueue, notification)
    
    -- Remove old notifications if too many
    while #NotificationQueue > MaxNotifications do
        local old = table.remove(NotificationQueue, 1)
        old.Background:Remove()
        old.Title:Remove()
        old.Text:Remove()
    end
    
    return notification
end

-- Update notifications
Connections["NotificationUpdate"] = RunService.RenderStepped:Connect(function()
    local toRemove = {}
    
    for i, notif in pairs(NotificationQueue) do
        if tick() - notif.StartTime > notif.Duration then
            table.insert(toRemove, i)
        else
            -- Reposition based on index
            local yOffset = (i - 1) * 70
            notif.Background.Position = Vector2.new(Camera.ViewportSize.X - 310, 10 + yOffset)
            notif.Title.Position = Vector2.new(Camera.ViewportSize.X - 305, 15 + yOffset)
            notif.Text.Position = Vector2.new(Camera.ViewportSize.X - 305, 38 + yOffset)
        end
    end
    
    -- Remove expired notifications
    for i = #toRemove, 1, -1 do
        local idx = toRemove[i]
        local notif = NotificationQueue[idx]
        notif.Background:Remove()
        notif.Title:Remove()
        notif.Text:Remove()
        table.remove(NotificationQueue, idx)
    end
end)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 53: PLAYER STATS TRACKING
═══════════════════════════════════════════════════════════════════════════ ]]--

local PlayerStats = {
    Kills = 0,
    Deaths = 0,
    PlayTime = 0,
    DistanceTraveled = 0,
    LastPosition = nil
}

-- Track play time
spawn(function()
    while true do
        PlayerStats.PlayTime = PlayerStats.PlayTime + 1
        task.wait(1)
    end
end)

-- Track distance traveled
Connections["DistanceTracker"] = RunService.Heartbeat:Connect(function()
    local hrp = getHRP()
    if hrp then
        if PlayerStats.LastPosition then
            local dist = (hrp.Position - PlayerStats.LastPosition).Magnitude
            if dist < 100 then -- Ignore teleports
                PlayerStats.DistanceTraveled = PlayerStats.DistanceTraveled + dist
            end
        end
        PlayerStats.LastPosition = hrp.Position
    end
end)

-- Track deaths
local function onLocalDeath()
    PlayerStats.Deaths = PlayerStats.Deaths + 1
end

-- Connect death tracking
if LocalCharacter then
    local hum = LocalCharacter:FindFirstChildOfClass("Humanoid")
    if hum then
        hum.Died:Connect(onLocalDeath)
    end
end

LocalPlayer.CharacterAdded:Connect(function(char)
    local hum = char:WaitForChild("Humanoid", 10)
    if hum then
        hum.Died:Connect(onLocalDeath)
    end
end)

-- Function to display stats
local function displayPlayerStats()
    local hours = math.floor(PlayerStats.PlayTime / 3600)
    local minutes = math.floor((PlayerStats.PlayTime % 3600) / 60)
    local seconds = PlayerStats.PlayTime % 60
    
    print("=== YOUR SESSION STATS ===")
    print("Play Time: " .. string.format("%02d:%02d:%02d", hours, minutes, seconds))
    print("Deaths: " .. PlayerStats.Deaths)
    print("Distance Traveled: " .. string.format("%.1f", PlayerStats.DistanceTraveled) .. " studs")
    print("==========================")
end

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 54: TOOL GRAB SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local function grabAllToolsInRange(radius)
    local hrp = getHRP()
    if not hrp then return 0 end
    
    local count = 0
    local backpack = getBackpack()
    
    for _, v in pairs(Workspace:GetDescendants()) do
        if v:IsA("Tool") then
            local handle = v:FindFirstChild("Handle")
            if handle then
                local dist = (handle.Position - hrp.Position).Magnitude
                if dist <= radius then
                    v.Parent = backpack or LocalCharacter
                    count = count + 1
                end
            end
        end
    end
    
    return count
end

local function grabSpecificTool(toolName)
    local hrp = getHRP()
    if not hrp then return false end
    
    local lowerName = string.lower(toolName)
    local backpack = getBackpack()
    
    for _, v in pairs(Workspace:GetDescendants()) do
        if v:IsA("Tool") and string.find(string.lower(v.Name), lowerName) then
            v.Parent = backpack or LocalCharacter
            return true
        end
    end
    
    return false
end

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 55: ANTI-KICK SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local AntiKickEnabled = false

local function enableAntiKick()
    if AntiKickEnabled then return end
    AntiKickEnabled = true
    
    -- Method 1: Hook kick function
    pcall(function()
        local oldKick = LocalPlayer.Kick
        LocalPlayer.Kick = function(self, reason)
            warn("Kick blocked! Reason: " .. tostring(reason))
            sendNotification("Anti-Kick", "Kick attempt blocked!")
        end
    end)
    
    -- Method 2: Prevent character removal
    pcall(function()
        local mt = getrawmetatable(game)
        if setreadonly then setreadonly(mt, false) end
        
        local oldNamecall = mt.__namecall
        mt.__namecall = newcclosure(function(self, ...)
            local method = getnamecallmethod()
            local args = {...}
            
            if method == "Kick" then
                warn("Kick blocked via namecall!")
                return
            end
            
            return oldNamecall(self, ...)
        end)
        
        if setreadonly then setreadonly(mt, true) end
    end)
end

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 56: CHAT COMMANDS SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local ChatCommandsEnabled = false
local CommandPrefix = "/"

local ChatCommands = {
    ["tp"] = function(args)
        local playerName = args[1]
        local target = findPlayer(playerName)
        if target and target.Character then
            local hrp = getHRP()
            local theirHRP = target.Character:FindFirstChild("HumanoidRootPart")
            if hrp and theirHRP then
                hrp.CFrame = theirHRP.CFrame * CFrame.new(0, 0, 5)
                sendNotification("Teleported", "Teleported to " .. target.Name)
            end
        end
    end,
    
    ["speed"] = function(args)
        local speed = tonumber(args[1]) or 16
        local hum = getHumanoid()
        if hum then
            hum.WalkSpeed = speed
            sendNotification("Speed", "Set speed to " .. speed)
        end
    end,
    
    ["jump"] = function(args)
        local power = tonumber(args[1]) or 50
        local hum = getHumanoid()
        if hum then
            hum.JumpPower = power
            sendNotification("Jump", "Set jump power to " .. power)
        end
    end,
    
    ["fly"] = function(args)
        Settings.FlyEnabled = not Settings.FlyEnabled
        if Settings.FlyEnabled then
            startCustomFly()
        else
            stopCustomFly()
        end
        sendNotification("Fly", Settings.FlyEnabled and "Enabled" or "Disabled")
    end,
    
    ["noclip"] = function(args)
        Settings.NoclipEnabled = not Settings.NoclipEnabled
        sendNotification("Noclip", Settings.NoclipEnabled and "Enabled" or "Disabled")
    end,
    
    ["god"] = function(args)
        Settings.GodModeEnabled = not Settings.GodModeEnabled
        sendNotification("God Mode", Settings.GodModeEnabled and "Enabled" or "Disabled")
    end,
    
    ["reset"] = function(args)
        local hum = getHumanoid()
        if hum then
            hum.Health = 0
        end
    end,
    
    ["rejoin"] = function(args)
        TeleportService:Teleport(GamePlaceId, LocalPlayer)
    end,
    
    ["esp"] = function(args)
        Settings.ESPEnabled = not Settings.ESPEnabled
        Settings.ESPBoxEnabled = Settings.ESPEnabled
        Settings.ESPNameEnabled = Settings.ESPEnabled
        sendNotification("ESP", Settings.ESPEnabled and "Enabled" or "Disabled")
    end,
    
    ["coords"] = function(args)
        local hrp = getHRP()
        if hrp then
            local pos = hrp.Position
            local coords = string.format("%.1f, %.1f, %.1f", pos.X, pos.Y, pos.Z)
            copyToClipboard(coords)
        end
    end,
    
    ["goto"] = function(args)
        local x = tonumber(args[1]) or 0
        local y = tonumber(args[2]) or 5
        local z = tonumber(args[3]) or 0
        local hrp = getHRP()
        if hrp then
            hrp.CFrame = CFrame.new(x, y, z)
            sendNotification("Teleported", "Teleported to " .. x .. ", " .. y .. ", " .. z)
        end
    end,
    
    ["help"] = function(args)
        print("=== CHAT COMMANDS ===")
        print("/tp [player] - Teleport to player")
        print("/speed [value] - Set walk speed")
        print("/jump [value] - Set jump power")
        print("/fly - Toggle fly")
        print("/noclip - Toggle noclip")
        print("/god - Toggle god mode")
        print("/reset - Kill yourself")
        print("/rejoin - Rejoin server")
        print("/esp - Toggle ESP")
        print("/coords - Copy coordinates")
        print("/goto x y z - Teleport to coords")
        print("=====================")
        sendNotification("Help", "Commands printed to output")
    end
}

local function parseCommand(message)
    if not string.sub(message, 1, 1) == CommandPrefix then return end
    
    local parts = string.split(message, " ")
    local command = string.lower(string.sub(parts[1], 2)) -- Remove prefix
    local args = {}
    
    for i = 2, #parts do
        table.insert(args, parts[i])
    end
    
    if ChatCommands[command] then
        ChatCommands[command](args)
    end
end

-- Hook chat
Connections["ChatCommands"] = LocalPlayer.Chatted:Connect(function(message)
    if ChatCommandsEnabled and string.sub(message, 1, 1) == CommandPrefix then
        parseCommand(message)
    end
end)


--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 57: AUTO FARM MANAGER
═══════════════════════════════════════════════════════════════════════════ ]]--

local AutoFarmManager = {
    Active = false,
    CurrentTask = nil,
    Tasks = {},
    Paused = false
}

function AutoFarmManager:AddTask(taskName, taskFunc, interval)
    self.Tasks[taskName] = {
        Func = taskFunc,
        Interval = interval or 1,
        LastRun = 0,
        Enabled = false
    }
end

function AutoFarmManager:EnableTask(taskName)
    if self.Tasks[taskName] then
        self.Tasks[taskName].Enabled = true
    end
end

function AutoFarmManager:DisableTask(taskName)
    if self.Tasks[taskName] then
        self.Tasks[taskName].Enabled = false
    end
end

function AutoFarmManager:Start()
    self.Active = true
    
    spawn(function()
        while self.Active do
            if not self.Paused then
                local currentTime = tick()
                
                for name, task in pairs(self.Tasks) do
                    if task.Enabled and (currentTime - task.LastRun) >= task.Interval then
                        pcall(task.Func)
                        task.LastRun = currentTime
                    end
                end
            end
            
            task.wait(0.1)
        end
    end)
end

function AutoFarmManager:Stop()
    self.Active = false
end

function AutoFarmManager:Pause()
    self.Paused = true
end

function AutoFarmManager:Resume()
    self.Paused = false
end

-- Initialize farm manager
AutoFarmManager:AddTask("CollectItems", function()
    local hrp = getHRP()
    if not hrp then return end
    
    for _, v in pairs(Workspace:GetDescendants()) do
        if v:IsA("ProximityPrompt") and v.Parent and v.Parent:IsA("BasePart") then
            local dist = (v.Parent.Position - hrp.Position).Magnitude
            if dist <= Settings.AutoCollectRadius then
                firePrompt(v)
            end
        end
    end
end, 1)

AutoFarmManager:AddTask("MaintainHealth", function()
    local hum = getHumanoid()
    if hum and hum.Health < hum.MaxHealth * 0.5 then
        -- Look for health items
        for _, v in pairs(Workspace:GetDescendants()) do
            local name = string.lower(v.Name)
            if v:IsA("BasePart") and (string.find(name, "health") or string.find(name, "medkit") or string.find(name, "heal")) then
                local hrp = getHRP()
                if hrp then
                    hrp.CFrame = v.CFrame + Vector3.new(0, 3, 0)
                    break
                end
            end
        end
    end
end, 5)

AutoFarmManager:AddTask("AvoidPlayers", function()
    if not Settings.AutoFarmAvoidPlayers then return end
    
    local hrp = getHRP()
    if not hrp then return end
    
    local closest, dist = getClosestPlayer(50, false, true, false)
    if closest and dist < 30 then
        -- Move away from player
        local theirHRP = closest.Character:FindFirstChild("HumanoidRootPart")
        if theirHRP then
            local direction = (hrp.Position - theirHRP.Position).Unit
            hrp.CFrame = hrp.CFrame + (direction * 20)
        end
    end
end, 2)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 58: WALLHACK SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local WallhackEnabled = false
local OriginalMaterials = {}
local OriginalTransparencies = {}

local function enableWallhack()
    if WallhackEnabled then return end
    WallhackEnabled = true
    
    for _, part in pairs(Workspace:GetDescendants()) do
        if part:IsA("BasePart") and not part:IsDescendantOf(LocalCharacter) then
            local name = string.lower(part.Name)
            
            -- Check if it's a wall-like object
            if string.find(name, "wall") or string.find(name, "door") or 
               string.find(name, "window") or part.Transparency < 0.1 then
                
                if not OriginalMaterials[part] then
                    OriginalMaterials[part] = part.Material
                    OriginalTransparencies[part] = part.Transparency
                end
                
                part.Material = Enum.Material.ForceField
                part.Transparency = 0.7
            end
        end
    end
end

local function disableWallhack()
    WallhackEnabled = false
    
    for part, material in pairs(OriginalMaterials) do
        if part and part.Parent then
            part.Material = material
        end
    end
    
    for part, transparency in pairs(OriginalTransparencies) do
        if part and part.Parent then
            part.Transparency = transparency
        end
    end
    
    OriginalMaterials = {}
    OriginalTransparencies = {}
end

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 59: PLAYER TRACKER SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local TrackedPlayers = {}

local function trackPlayer(player)
    if TrackedPlayers[player] then return end
    
    TrackedPlayers[player] = {
        Beam = nil,
        LastKnownPosition = nil,
        TrackStart = tick()
    }
    
    -- Create beam to tracked player
    local beam = Instance.new("Beam")
    beam.Name = "TrackerBeam"
    
    local attachment0 = Instance.new("Attachment")
    local attachment1 = Instance.new("Attachment")
    
    beam.FaceCamera = true
    beam.Width0 = 0.5
    beam.Width1 = 0.5
    beam.Color = ColorSequence.new(Color3.fromRGB(255, 255, 0))
    beam.LightEmission = 1
    beam.Transparency = NumberSequence.new(0.5)
    
    TrackedPlayers[player].Beam = beam
    TrackedPlayers[player].Attachment0 = attachment0
    TrackedPlayers[player].Attachment1 = attachment1
end

local function untrackPlayer(player)
    if TrackedPlayers[player] then
        if TrackedPlayers[player].Beam then
            TrackedPlayers[player].Beam:Destroy()
        end
        if TrackedPlayers[player].Attachment0 then
            TrackedPlayers[player].Attachment0:Destroy()
        end
        if TrackedPlayers[player].Attachment1 then
            TrackedPlayers[player].Attachment1:Destroy()
        end
        TrackedPlayers[player] = nil
    end
end

local function updateTrackers()
    local myHRP = getHRP()
    if not myHRP then return end
    
    for player, data in pairs(TrackedPlayers) do
        if player and player.Parent and player.Character then
            local theirHRP = player.Character:FindFirstChild("HumanoidRootPart")
            if theirHRP then
                data.LastKnownPosition = theirHRP.Position
                
                -- Update beam positions
                if data.Attachment0 and data.Attachment1 then
                    data.Attachment0.Parent = myHRP
                    data.Attachment1.Parent = theirHRP
                    
                    if data.Beam then
                        data.Beam.Attachment0 = data.Attachment0
                        data.Beam.Attachment1 = data.Attachment1
                        data.Beam.Parent = Workspace
                    end
                end
            end
        else
            untrackPlayer(player)
        end
    end
end

-- Tracker update loop
Connections["TrackerUpdate"] = RunService.Heartbeat:Connect(updateTrackers)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 60: MOVEMENT RECORDER
═══════════════════════════════════════════════════════════════════════════ ]]--

local MovementRecorder = {
    Recording = false,
    Playing = false,
    Frames = {},
    CurrentFrame = 0,
    RecordInterval = 0.1
}

function MovementRecorder:StartRecording()
    if self.Recording then return end
    
    self.Recording = true
    self.Frames = {}
    
    spawn(function()
        while self.Recording do
            local hrp = getHRP()
            if hrp then
                table.insert(self.Frames, {
                    CFrame = hrp.CFrame,
                    Timestamp = tick()
                })
            end
            task.wait(self.RecordInterval)
        end
    end)
    
    sendNotification("Recorder", "Recording started...")
end

function MovementRecorder:StopRecording()
    self.Recording = false
    sendNotification("Recorder", "Recorded " .. #self.Frames .. " frames")
end

function MovementRecorder:PlayRecording()
    if self.Playing or #self.Frames == 0 then return end
    
    self.Playing = true
    self.CurrentFrame = 0
    
    spawn(function()
        for i, frame in ipairs(self.Frames) do
            if not self.Playing then break end
            
            local hrp = getHRP()
            if hrp then
                hrp.CFrame = frame.CFrame
            end
            
            self.CurrentFrame = i
            
            if i < #self.Frames then
                local nextFrame = self.Frames[i + 1]
                local delay = (nextFrame.Timestamp - frame.Timestamp)
                task.wait(math.max(delay, 0.01))
            end
        end
        
        self.Playing = false
        sendNotification("Recorder", "Playback finished")
    end)
    
    sendNotification("Recorder", "Playing recording...")
end

function MovementRecorder:StopPlayback()
    self.Playing = false
end

function MovementRecorder:ClearRecording()
    self.Frames = {}
    self.CurrentFrame = 0
    sendNotification("Recorder", "Recording cleared")
end

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 61: HITMARKER SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local HitmarkerEnabled = false
local HitmarkerSize = 20
local HitmarkerDuration = 0.3
local HitmarkerColor = Color3.fromRGB(255, 0, 0)

local ActiveHitmarkers = {}

local function createHitmarker(position)
    if not HitmarkerEnabled then return end
    
    local screenPos, onScreen = Camera:WorldToScreenPoint(position)
    if not onScreen then return end
    
    local lines = {
        Drawing.new("Line"),
        Drawing.new("Line"),
        Drawing.new("Line"),
        Drawing.new("Line")
    }
    
    local center = Vector2.new(screenPos.X, screenPos.Y)
    local offset = HitmarkerSize / 2
    
    -- Top-left to center
    lines[1].From = center + Vector2.new(-offset, -offset)
    lines[1].To = center + Vector2.new(-offset/2, -offset/2)
    
    -- Top-right to center
    lines[2].From = center + Vector2.new(offset, -offset)
    lines[2].To = center + Vector2.new(offset/2, -offset/2)
    
    -- Bottom-left to center
    lines[3].From = center + Vector2.new(-offset, offset)
    lines[3].To = center + Vector2.new(-offset/2, offset/2)
    
    -- Bottom-right to center
    lines[4].From = center + Vector2.new(offset, offset)
    lines[4].To = center + Vector2.new(offset/2, offset/2)
    
    for _, line in pairs(lines) do
        line.Visible = true
        line.Color = HitmarkerColor
        line.Thickness = 2
        line.Transparency = 1
    end
    
    local hitmarker = {
        Lines = lines,
        StartTime = tick(),
        Position = center
    }
    
    table.insert(ActiveHitmarkers, hitmarker)
end

-- Hitmarker update loop
Connections["HitmarkerUpdate"] = RunService.RenderStepped:Connect(function()
    local toRemove = {}
    
    for i, hitmarker in pairs(ActiveHitmarkers) do
        local elapsed = tick() - hitmarker.StartTime
        
        if elapsed >= HitmarkerDuration then
            table.insert(toRemove, i)
        else
            -- Fade out
            local alpha = 1 - (elapsed / HitmarkerDuration)
            for _, line in pairs(hitmarker.Lines) do
                line.Transparency = alpha
            end
        end
    end
    
    -- Remove expired hitmarkers
    for i = #toRemove, 1, -1 do
        local idx = toRemove[i]
        local hitmarker = ActiveHitmarkers[idx]
        for _, line in pairs(hitmarker.Lines) do
            line:Remove()
        end
        table.remove(ActiveHitmarkers, idx)
    end
end)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 62: SOUND ESP SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local SoundESPEnabled = false
local SoundESPRadius = 100

local function playSoundAtPosition(position, soundType)
    if not SoundESPEnabled then return end
    
    local myHRP = getHRP()
    if not myHRP then return end
    
    local dist = (position - myHRP.Position).Magnitude
    if dist > SoundESPRadius then return end
    
    local soundId = ""
    
    if soundType == "Footstep" then
        soundId = "rbxassetid://142082167"
    elseif soundType == "Gunshot" then
        soundId = "rbxassetid://1026252448"
    elseif soundType == "Reload" then
        soundId = "rbxassetid://537744814"
    end
    
    if soundId ~= "" then
        local sound = Instance.new("Sound")
        sound.SoundId = soundId
        sound.Volume = math.clamp(1 - (dist / SoundESPRadius), 0.1, 1)
        
        -- Determine stereo position
        local direction = (position - Camera.CFrame.Position).Unit
        local cameraRight = Camera.CFrame.RightVector
        local stereo = direction:Dot(cameraRight)
        
        -- Create stereo effect (pseudo)
        if stereo > 0.5 then
            sound.Volume = sound.Volume * 0.7 -- Quieter in other ear
        elseif stereo < -0.5 then
            sound.Volume = sound.Volume * 0.7
        end
        
        sound.Parent = SoundService
        sound:Play()
        
        Debris:AddItem(sound, 2)
    end
end

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 63: PREDICTION SYSTEM FOR AIMBOT
═══════════════════════════════════════════════════════════════════════════ ]]--

local PredictionSystem = {
    Enabled = false,
    Strength = 0.1,
    VelocityHistory = {}
}

function PredictionSystem:GetPredictedPosition(player)
    if not self.Enabled then return nil end
    
    if not player or not player.Character then return nil end
    
    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local targetPart = player.Character:FindFirstChild(Settings.AimbotPart) or hrp
    
    -- Get current velocity
    local velocity = hrp.Velocity
    
    -- Store velocity history for smoothing
    if not self.VelocityHistory[player] then
        self.VelocityHistory[player] = {}
    end
    
    table.insert(self.VelocityHistory[player], velocity)
    
    -- Keep only last 10 samples
    while #self.VelocityHistory[player] > 10 do
        table.remove(self.VelocityHistory[player], 1)
    end
    
    -- Average velocity
    local avgVelocity = Vector3.new(0, 0, 0)
    for _, vel in pairs(self.VelocityHistory[player]) do
        avgVelocity = avgVelocity + vel
    end
    avgVelocity = avgVelocity / #self.VelocityHistory[player]
    
    -- Calculate predicted position
    local myHRP = getHRP()
    if not myHRP then return targetPart.Position end
    
    local distance = (targetPart.Position - myHRP.Position).Magnitude
    local bulletTime = distance / 1000 -- Assume bullet speed of 1000
    
    local predictedPosition = targetPart.Position + (avgVelocity * bulletTime * self.Strength)
    
    return predictedPosition
end

function PredictionSystem:ClearHistory(player)
    self.VelocityHistory[player] = nil
end

-- Clean up on player leave
Players.PlayerRemoving:Connect(function(player)
    PredictionSystem:ClearHistory(player)
end)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 64: KILL AURA SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local KillAuraEnabled = false
local KillAuraRadius = 15
local KillAuraInterval = 0.1

local function activateKillAura()
    if not KillAuraEnabled then return end
    
    local myHRP = getHRP()
    if not myHRP then return end
    
    local tool = getEquippedTool()
    if not tool then return end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local theirHRP = player.Character:FindFirstChild("HumanoidRootPart")
            if theirHRP then
                local dist = (theirHRP.Position - myHRP.Position).Magnitude
                if dist <= KillAuraRadius then
                    -- Face the target
                    myHRP.CFrame = CFrame.new(myHRP.Position, theirHRP.Position)
                    
                    -- Activate tool
                    pcall(function()
                        tool:Activate()
                    end)
                    
                    task.wait(KillAuraInterval)
                end
            end
        end
    end
end

-- Kill aura loop
spawn(function()
    while true do
        if KillAuraEnabled then
            pcall(activateKillAura)
        end
        task.wait(0.1)
    end
end)


--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 65: AIM ASSIST SYSTEM (CONTROLLER SUPPORT)
═══════════════════════════════════════════════════════════════════════════ ]]--

local AimAssistEnabled = false
local AimAssistStrength = 0.5
local AimAssistStickiness = 0.3
local CurrentAimTarget = nil

local function calculateAimAssist()
    if not AimAssistEnabled then return end
    
    local closest = getClosestPlayerToMouse()
    if not closest then 
        CurrentAimTarget = nil
        return 
    end
    
    if closest ~= CurrentAimTarget then
        -- New target acquired
        CurrentAimTarget = closest
    end
    
    if CurrentAimTarget and CurrentAimTarget.Character then
        local targetPart = CurrentAimTarget.Character:FindFirstChild(Settings.AimbotPart) or CurrentAimTarget.Character:FindFirstChild("Head")
        if targetPart then
            local targetPos = Camera:WorldToScreenPoint(targetPart.Position)
            local mousePos = UserInputService:GetMouseLocation()
            
            local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
            local distToTarget = (Vector2.new(targetPos.X, targetPos.Y) - screenCenter).Magnitude
            
            -- Only assist if within FOV
            if distToTarget < Settings.AimbotFOV then
                local direction = (Vector2.new(targetPos.X, targetPos.Y) - mousePos)
                local assistAmount = direction * AimAssistStrength * (1 - distToTarget / Settings.AimbotFOV)
                
                -- Apply stickiness - slower movement away from target
                if mousemoverel then
                    mousemoverel(assistAmount.X * 0.1, assistAmount.Y * 0.1)
                end
            end
        end
    end
end

-- Aim assist loop
Connections["AimAssistLoop"] = RunService.RenderStepped:Connect(function()
    if AimAssistEnabled and AimbotHolding then
        calculateAimAssist()
    end
end)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 66: SPECTATOR LIST
═══════════════════════════════════════════════════════════════════════════ ]]--

local SpectatorListEnabled = false
local SpectatorGui = nil
local PotentialSpectators = {}

local function updateSpectatorList()
    if not SpectatorListEnabled then return end
    
    PotentialSpectators = {}
    
    local myHRP = getHRP()
    if not myHRP then return end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local theirHead = player.Character:FindFirstChild("Head")
            local theirHRP = player.Character:FindFirstChild("HumanoidRootPart")
            
            if theirHead and theirHRP then
                -- Check if they're looking at us
                local directionToUs = (myHRP.Position - theirHead.Position).Unit
                local theirLookVector = theirHead.CFrame.LookVector
                
                local dotProduct = directionToUs:Dot(theirLookVector)
                
                -- If dot product is high, they're looking towards us
                if dotProduct > 0.7 then
                    table.insert(PotentialSpectators, {
                        Player = player,
                        LookStrength = dotProduct,
                        Distance = (theirHRP.Position - myHRP.Position).Magnitude
                    })
                end
            end
        end
    end
end

-- Spectator list update
spawn(function()
    while true do
        if SpectatorListEnabled then
            updateSpectatorList()
        end
        task.wait(1)
    end
end)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 67: MACRO SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local MacroSystem = {
    Macros = {},
    Recording = false,
    CurrentMacro = nil,
    Playing = false
}

function MacroSystem:CreateMacro(name)
    self.Macros[name] = {
        Actions = {},
        CreatedAt = tick()
    }
    return self.Macros[name]
end

function MacroSystem:StartRecording(macroName)
    if self.Recording then return end
    
    self.CurrentMacro = self:CreateMacro(macroName)
    self.Recording = true
    
    sendNotification("Macro", "Recording macro: " .. macroName)
end

function MacroSystem:StopRecording()
    self.Recording = false
    sendNotification("Macro", "Stopped recording. " .. #self.CurrentMacro.Actions .. " actions recorded.")
end

function MacroSystem:AddAction(actionType, data)
    if not self.Recording or not self.CurrentMacro then return end
    
    table.insert(self.CurrentMacro.Actions, {
        Type = actionType,
        Data = data,
        Timestamp = tick()
    })
end

function MacroSystem:PlayMacro(macroName)
    if self.Playing then return end
    
    local macro = self.Macros[macroName]
    if not macro then
        sendNotification("Macro", "Macro not found!")
        return
    end
    
    self.Playing = true
    
    spawn(function()
        local startTime = tick()
        local lastActionTime = 0
        
        for i, action in ipairs(macro.Actions) do
            if not self.Playing then break end
            
            -- Wait for proper timing
            if i > 1 then
                local waitTime = action.Timestamp - macro.Actions[i-1].Timestamp
                task.wait(waitTime)
            end
            
            -- Execute action
            if action.Type == "Move" then
                local hrp = getHRP()
                if hrp then
                    hrp.CFrame = CFrame.new(action.Data.Position)
                end
            elseif action.Type == "Jump" then
                local hum = getHumanoid()
                if hum then
                    hum:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            elseif action.Type == "Activate" then
                local tool = getEquippedTool()
                if tool then
                    tool:Activate()
                end
            end
        end
        
        self.Playing = false
        sendNotification("Macro", "Macro playback finished")
    end)
end

function MacroSystem:StopPlayback()
    self.Playing = false
end

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 68: INVENTORY MANAGER
═══════════════════════════════════════════════════════════════════════════ ]]--

local InventoryManager = {
    SortMode = "Name", -- Name, Type, Recent
    FilterMode = "All" -- All, Weapons, Tools, Items
}

function InventoryManager:GetInventory()
    local inventory = {}
    
    -- From character
    if LocalCharacter then
        for _, item in pairs(LocalCharacter:GetChildren()) do
            if item:IsA("Tool") then
                table.insert(inventory, {
                    Tool = item,
                    Equipped = true,
                    Source = "Character"
                })
            end
        end
    end
    
    -- From backpack
    local backpack = getBackpack()
    if backpack then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                table.insert(inventory, {
                    Tool = item,
                    Equipped = false,
                    Source = "Backpack"
                })
            end
        end
    end
    
    -- Sort
    if self.SortMode == "Name" then
        table.sort(inventory, function(a, b)
            return a.Tool.Name < b.Tool.Name
        end)
    end
    
    return inventory
end

function InventoryManager:EquipTool(toolName)
    local backpack = getBackpack()
    if backpack then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") and item.Name == toolName then
                item.Parent = LocalCharacter
                return true
            end
        end
    end
    return false
end

function InventoryManager:UnequipTool(toolName)
    if LocalCharacter then
        for _, item in pairs(LocalCharacter:GetChildren()) do
            if item:IsA("Tool") and item.Name == toolName then
                item.Parent = getBackpack()
                return true
            end
        end
    end
    return false
end

function InventoryManager:DropTool(toolName)
    local hrp = getHRP()
    if not hrp then return false end
    
    local inventory = self:GetInventory()
    for _, entry in pairs(inventory) do
        if entry.Tool.Name == toolName then
            entry.Tool.Parent = Workspace
            local handle = entry.Tool:FindFirstChild("Handle")
            if handle then
                handle.CFrame = hrp.CFrame * CFrame.new(0, 0, -5)
            end
            return true
        end
    end
    return false
end

function InventoryManager:GetToolCount()
    return #self:GetInventory()
end

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 69: DAMAGE INDICATOR SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local DamageIndicatorEnabled = false
local DamageIndicators = {}

local function createDamageIndicator(damage, position, isCritical)
    if not DamageIndicatorEnabled then return end
    
    local screenPos, onScreen = Camera:WorldToScreenPoint(position)
    if not onScreen then return end
    
    local indicator = {
        Text = Drawing.new("Text"),
        StartTime = tick(),
        StartY = screenPos.Y,
        X = screenPos.X
    }
    
    indicator.Text.Visible = true
    indicator.Text.Text = (isCritical and "CRIT! " or "") .. "-" .. math.floor(damage)
    indicator.Text.Color = isCritical and Color3.fromRGB(255, 215, 0) or Color3.fromRGB(255, 50, 50)
    indicator.Text.Size = isCritical and 24 or 18
    indicator.Text.Center = true
    indicator.Text.Outline = true
    indicator.Text.OutlineColor = Color3.new(0, 0, 0)
    indicator.Text.Font = Drawing.Fonts.UI
    indicator.Text.Position = Vector2.new(screenPos.X, screenPos.Y)
    
    table.insert(DamageIndicators, indicator)
end

-- Damage indicator update loop
Connections["DamageIndicatorUpdate"] = RunService.RenderStepped:Connect(function()
    local toRemove = {}
    
    for i, indicator in pairs(DamageIndicators) do
        local elapsed = tick() - indicator.StartTime
        local duration = 1.5
        
        if elapsed >= duration then
            table.insert(toRemove, i)
        else
            -- Float up and fade out
            local progress = elapsed / duration
            local yOffset = progress * 50
            local alpha = 1 - progress
            
            indicator.Text.Position = Vector2.new(indicator.X, indicator.StartY - yOffset)
            indicator.Text.Transparency = alpha
        end
    end
    
    -- Remove expired indicators
    for i = #toRemove, 1, -1 do
        local idx = toRemove[i]
        DamageIndicators[idx].Text:Remove()
        table.remove(DamageIndicators, idx)
    end
end)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 70: PLAYER HISTORY TRACKER
═══════════════════════════════════════════════════════════════════════════ ]]--

local PlayerHistory = {
    JoinHistory = {},
    LeaveHistory = {},
    MaxHistory = 50
}

function PlayerHistory:LogJoin(player)
    table.insert(self.JoinHistory, 1, {
        Name = player.Name,
        DisplayName = player.DisplayName,
        UserId = player.UserId,
        Timestamp = os.time()
    })
    
    -- Trim history
    while #self.JoinHistory > self.MaxHistory do
        table.remove(self.JoinHistory)
    end
end

function PlayerHistory:LogLeave(player)
    table.insert(self.LeaveHistory, 1, {
        Name = player.Name,
        DisplayName = player.DisplayName,
        UserId = player.UserId,
        Timestamp = os.time()
    })
    
    -- Trim history
    while #self.LeaveHistory > self.MaxHistory do
        table.remove(self.LeaveHistory)
    end
end

function PlayerHistory:GetHistory()
    return {
        Joins = self.JoinHistory,
        Leaves = self.LeaveHistory
    }
end

function PlayerHistory:PrintHistory()
    print("=== RECENT JOINS ===")
    for i, entry in ipairs(self.JoinHistory) do
        if i > 10 then break end
        local timeAgo = os.time() - entry.Timestamp
        print(string.format("%s joined %d seconds ago", entry.Name, timeAgo))
    end
    
    print("\n=== RECENT LEAVES ===")
    for i, entry in ipairs(self.LeaveHistory) do
        if i > 10 then break end
        local timeAgo = os.time() - entry.Timestamp
        print(string.format("%s left %d seconds ago", entry.Name, timeAgo))
    end
end

-- Connect player events
Players.PlayerAdded:Connect(function(player)
    PlayerHistory:LogJoin(player)
end)

Players.PlayerRemoving:Connect(function(player)
    PlayerHistory:LogLeave(player)
end)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 71: AUTO DODGE SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local AutoDodgeEnabled = false
local DodgeDistance = 10
local DodgeCooldown = 0.5
local LastDodgeTime = 0

local function performDodge(direction)
    local hrp = getHRP()
    if not hrp then return end
    
    if tick() - LastDodgeTime < DodgeCooldown then return end
    
    hrp.CFrame = hrp.CFrame + (direction * DodgeDistance)
    LastDodgeTime = tick()
end

local function checkForIncomingThreats()
    if not AutoDodgeEnabled then return end
    
    local myHRP = getHRP()
    if not myHRP then return end
    
    -- Check for nearby players with weapons
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local theirHRP = player.Character:FindFirstChild("HumanoidRootPart")
            local theirHead = player.Character:FindFirstChild("Head")
            
            if theirHRP and theirHead then
                local dist = (theirHRP.Position - myHRP.Position).Magnitude
                
                if dist < 30 then
                    -- Check if they're aiming at us
                    local directionToUs = (myHRP.Position - theirHead.Position).Unit
                    local theirLookVector = theirHead.CFrame.LookVector
                    
                    if directionToUs:Dot(theirLookVector) > 0.9 then
                        -- They're aiming at us! Dodge!
                        local dodgeDirection = (myHRP.Position - theirHRP.Position).Unit
                        local perpendicular = Vector3.new(-dodgeDirection.Z, 0, dodgeDirection.X)
                        
                        -- Randomly dodge left or right
                        if math.random() > 0.5 then
                            performDodge(perpendicular)
                        else
                            performDodge(-perpendicular)
                        end
                    end
                end
            end
        end
    end
end

-- Auto dodge loop
Connections["AutoDodgeLoop"] = RunService.Heartbeat:Connect(checkForIncomingThreats)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 72: CROSSHAIR CUSTOMIZATION
═══════════════════════════════════════════════════════════════════════════ ]]--

local CrosshairPresets = {
    ["Default"] = {
        Size = 10,
        Gap = 5,
        Thickness = 2,
        Color = Color3.fromRGB(0, 255, 0),
        Dot = false
    },
    ["Dot"] = {
        Size = 0,
        Gap = 0,
        Thickness = 2,
        Color = Color3.fromRGB(255, 0, 0),
        Dot = true,
        DotSize = 3
    },
    ["Cross"] = {
        Size = 15,
        Gap = 0,
        Thickness = 2,
        Color = Color3.fromRGB(255, 255, 255),
        Dot = false
    },
    ["Circle"] = {
        Size = 8,
        Gap = 3,
        Thickness = 2,
        Color = Color3.fromRGB(0, 255, 255),
        Dot = true,
        DotSize = 2
    },
    ["Dynamic"] = {
        Size = 10,
        Gap = 5,
        Thickness = 2,
        Color = Color3.fromRGB(255, 255, 0),
        Dot = true,
        DotSize = 2,
        Dynamic = true
    }
}

local function applyCrosshairPreset(presetName)
    local preset = CrosshairPresets[presetName]
    if not preset then return end
    
    Settings.CrosshairSize = preset.Size
    Settings.CrosshairGap = preset.Gap
    Settings.CrosshairThickness = preset.Thickness
    Settings.CrosshairColor = preset.Color
    Settings.CrosshairDot = preset.Dot
    Settings.CrosshairDotSize = preset.DotSize or 2
    
    sendNotification("Crosshair", "Applied " .. presetName .. " preset")
end

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 73: WORLD SCANNER
═══════════════════════════════════════════════════════════════════════════ ]]--

local WorldScanner = {
    LastScanResults = {}
}

function WorldScanner:ScanForItems(itemType)
    local results = {}
    local hrp = getHRP()
    if not hrp then return results end
    
    for _, v in pairs(Workspace:GetDescendants()) do
        local name = string.lower(v.Name)
        local match = false
        
        if itemType == "Tools" and v:IsA("Tool") then
            match = true
        elseif itemType == "ProximityPrompts" and v:IsA("ProximityPrompt") then
            match = true
        elseif itemType == "Money" and (string.find(name, "money") or string.find(name, "cash") or string.find(name, "dollar")) then
            match = true
        elseif itemType == "Weapons" and v:IsA("Tool") and (string.find(name, "gun") or string.find(name, "pistol") or string.find(name, "rifle")) then
            match = true
        elseif itemType == "ATMs" and string.find(name, "atm") then
            match = true
        elseif itemType == "Vehicles" and (v:IsA("VehicleSeat") or string.find(name, "car") or string.find(name, "vehicle")) then
            match = true
        end
        
        if match then
            local position = v.Position or (v:IsA("BasePart") and v.Position) or (v.Parent and v.Parent:IsA("BasePart") and v.Parent.Position)
            if position then
                local dist = (position - hrp.Position).Magnitude
                table.insert(results, {
                    Object = v,
                    Name = v.Name,
                    Position = position,
                    Distance = dist
                })
            end
        end
    end
    
    -- Sort by distance
    table.sort(results, function(a, b)
        return a.Distance < b.Distance
    end)
    
    self.LastScanResults = results
    return results
end

function WorldScanner:TeleportToNearest(itemType)
    local results = self:ScanForItems(itemType)
    if #results > 0 then
        local hrp = getHRP()
        if hrp then
            hrp.CFrame = CFrame.new(results[1].Position + Vector3.new(0, 3, 0))
            sendNotification("Scanner", "Teleported to " .. results[1].Name)
            return true
        end
    end
    sendNotification("Scanner", "No " .. itemType .. " found!")
    return false
end

function WorldScanner:PrintResults(itemType)
    local results = self:ScanForItems(itemType)
    print("=== SCAN RESULTS: " .. itemType .. " ===")
    for i, result in ipairs(results) do
        if i > 20 then break end
        print(string.format("%d. %s - %.1f studs", i, result.Name, result.Distance))
    end
    print("Total: " .. #results .. " found")
    print("================================")
    sendNotification("Scanner", "Found " .. #results .. " " .. itemType)
end


--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 74: COMBAT LOG SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local CombatLog = {
    Entries = {},
    MaxEntries = 100
}

function CombatLog:AddEntry(entryType, data)
    table.insert(self.Entries, 1, {
        Type = entryType,
        Data = data,
        Timestamp = tick(),
        FormattedTime = os.date("%H:%M:%S")
    })
    
    while #self.Entries > self.MaxEntries do
        table.remove(self.Entries)
    end
end

function CombatLog:LogKill(killer, victim)
    self:AddEntry("Kill", {
        Killer = killer,
        Victim = victim
    })
end

function CombatLog:LogDeath(player, cause)
    self:AddEntry("Death", {
        Player = player,
        Cause = cause or "Unknown"
    })
end

function CombatLog:LogDamage(source, target, amount)
    self:AddEntry("Damage", {
        Source = source,
        Target = target,
        Amount = amount
    })
end

function CombatLog:PrintLog()
    print("=== COMBAT LOG ===")
    for i, entry in ipairs(self.Entries) do
        if i > 20 then break end
        
        if entry.Type == "Kill" then
            print(string.format("[%s] %s killed %s", entry.FormattedTime, entry.Data.Killer, entry.Data.Victim))
        elseif entry.Type == "Death" then
            print(string.format("[%s] %s died (%s)", entry.FormattedTime, entry.Data.Player, entry.Data.Cause))
        elseif entry.Type == "Damage" then
            print(string.format("[%s] %s dealt %d damage to %s", entry.FormattedTime, entry.Data.Source, entry.Data.Amount, entry.Data.Target))
        end
    end
    print("==================")
end

-- Monitor deaths for combat log
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        spawn(function()
            while player.Parent do
                if player.Character then
                    local hum = player.Character:WaitForChild("Humanoid", 5)
                    if hum then
                        local lastHealth = hum.Health
                        hum.HealthChanged:Connect(function(newHealth)
                            if newHealth < lastHealth then
                                -- Player took damage
                                CombatLog:LogDamage("Unknown", player.Name, lastHealth - newHealth)
                            end
                            lastHealth = newHealth
                        end)
                        
                        hum.Died:Connect(function()
                            CombatLog:LogDeath(player.Name, "Unknown")
                        end)
                    end
                end
                task.wait(1)
            end
        end)
    end
end

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 75: CUSTOM KEYBIND MANAGER
═══════════════════════════════════════════════════════════════════════════ ]]--

local KeybindManager = {
    Binds = {},
    ListeningForBind = false,
    CurrentBindName = nil
}

function KeybindManager:RegisterBind(name, defaultKey, callback)
    self.Binds[name] = {
        Key = defaultKey,
        Callback = callback,
        Enabled = true
    }
end

function KeybindManager:SetBind(name, key)
    if self.Binds[name] then
        self.Binds[name].Key = key
        sendNotification("Keybind", name .. " set to " .. tostring(key))
    end
end

function KeybindManager:GetBind(name)
    if self.Binds[name] then
        return self.Binds[name].Key
    end
    return nil
end

function KeybindManager:EnableBind(name)
    if self.Binds[name] then
        self.Binds[name].Enabled = true
    end
end

function KeybindManager:DisableBind(name)
    if self.Binds[name] then
        self.Binds[name].Enabled = false
    end
end

function KeybindManager:ProcessInput(input)
    if self.ListeningForBind then
        self:SetBind(self.CurrentBindName, input.KeyCode)
        self.ListeningForBind = false
        self.CurrentBindName = nil
        return true
    end
    
    for name, bind in pairs(self.Binds) do
        if bind.Enabled and input.KeyCode == bind.Key then
            if bind.Callback then
                bind.Callback()
            end
        end
    end
    
    return false
end

function KeybindManager:StartListening(bindName)
    self.ListeningForBind = true
    self.CurrentBindName = bindName
    sendNotification("Keybind", "Press a key for " .. bindName .. "...")
end

-- Register default keybinds
KeybindManager:RegisterBind("ToggleFly", Enum.KeyCode.V, function()
    -- Handled by pastebin
end)

KeybindManager:RegisterBind("ToggleNoclip", Enum.KeyCode.N, function()
    Settings.NoclipEnabled = not Settings.NoclipEnabled
    sendNotification("Noclip", Settings.NoclipEnabled and "Enabled" or "Disabled")
end)

KeybindManager:RegisterBind("StopLoops", Enum.KeyCode.L, function()
    Settings.TPLoopEnabled = false
    Settings.FlingEnabled = false
    Settings.AnnoyEnabled = false
    Settings.OrbitEnabled = false
    sendNotification("Loops", "All loops stopped!")
end)

KeybindManager:RegisterBind("TPToMouse", Enum.KeyCode.E, function()
    local hrp = getHRP()
    if hrp then
        hrp.CFrame = CFrame.new(Mouse.Hit.Position + Vector3.new(0, 3, 0))
    end
end)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 76: NETWORK STATISTICS
═══════════════════════════════════════════════════════════════════════════ ]]--

local NetworkStats = {
    PingHistory = {},
    MaxHistory = 100,
    HighPingThreshold = 150
}

function NetworkStats:UpdatePing()
    local ping = math.floor(LocalPlayer:GetNetworkPing() * 1000)
    table.insert(self.PingHistory, {
        Ping = ping,
        Timestamp = tick()
    })
    
    while #self.PingHistory > self.MaxHistory do
        table.remove(self.PingHistory, 1)
    end
    
    return ping
end

function NetworkStats:GetAveragePing()
    if #self.PingHistory == 0 then return 0 end
    
    local total = 0
    for _, entry in pairs(self.PingHistory) do
        total = total + entry.Ping
    end
    
    return total / #self.PingHistory
end

function NetworkStats:GetMinPing()
    if #self.PingHistory == 0 then return 0 end
    
    local min = math.huge
    for _, entry in pairs(self.PingHistory) do
        if entry.Ping < min then
            min = entry.Ping
        end
    end
    
    return min
end

function NetworkStats:GetMaxPing()
    if #self.PingHistory == 0 then return 0 end
    
    local max = 0
    for _, entry in pairs(self.PingHistory) do
        if entry.Ping > max then
            max = entry.Ping
        end
    end
    
    return max
end

function NetworkStats:IsHighPing()
    return self:GetAveragePing() > self.HighPingThreshold
end

function NetworkStats:PrintStats()
    print("=== NETWORK STATISTICS ===")
    print("Current Ping: " .. self:UpdatePing() .. "ms")
    print("Average Ping: " .. math.floor(self:GetAveragePing()) .. "ms")
    print("Min Ping: " .. self:GetMinPing() .. "ms")
    print("Max Ping: " .. self:GetMaxPing() .. "ms")
    print("High Ping: " .. tostring(self:IsHighPing()))
    print("==========================")
end

-- Update ping every second
spawn(function()
    while true do
        NetworkStats:UpdatePing()
        task.wait(1)
    end
end)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 77: THREAT DETECTOR
═══════════════════════════════════════════════════════════════════════════ ]]--

local ThreatDetector = {
    Enabled = false,
    AlertRadius = 50,
    Threats = {}
}

function ThreatDetector:ScanForThreats()
    if not self.Enabled then return end
    
    self.Threats = {}
    
    local myHRP = getHRP()
    if not myHRP then return end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local theirHRP = player.Character:FindFirstChild("HumanoidRootPart")
            local theirHum = player.Character:FindFirstChildOfClass("Humanoid")
            
            if theirHRP and theirHum and theirHum.Health > 0 then
                local dist = (theirHRP.Position - myHRP.Position).Magnitude
                
                if dist <= self.AlertRadius then
                    local threatLevel = 0
                    local reasons = {}
                    
                    -- Check if they have a weapon
                    for _, item in pairs(player.Character:GetChildren()) do
                        if item:IsA("Tool") then
                            local name = string.lower(item.Name)
                            if string.find(name, "gun") or string.find(name, "pistol") or string.find(name, "rifle") or string.find(name, "knife") then
                                threatLevel = threatLevel + 3
                                table.insert(reasons, "Armed")
                            end
                        end
                    end
                    
                    -- Check if they're looking at us
                    local theirHead = player.Character:FindFirstChild("Head")
                    if theirHead then
                        local directionToUs = (myHRP.Position - theirHead.Position).Unit
                        local theirLookVector = theirHead.CFrame.LookVector
                        
                        if directionToUs:Dot(theirLookVector) > 0.8 then
                            threatLevel = threatLevel + 2
                            table.insert(reasons, "Looking at you")
                        end
                    end
                    
                    -- Check if they're moving towards us
                    if theirHRP.Velocity.Magnitude > 5 then
                        local velocityDir = theirHRP.Velocity.Unit
                        local dirToUs = (myHRP.Position - theirHRP.Position).Unit
                        
                        if velocityDir:Dot(dirToUs) > 0.5 then
                            threatLevel = threatLevel + 1
                            table.insert(reasons, "Approaching")
                        end
                    end
                    
                    -- Close proximity
                    if dist < 15 then
                        threatLevel = threatLevel + 2
                        table.insert(reasons, "Close proximity")
                    end
                    
                    if threatLevel > 0 then
                        table.insert(self.Threats, {
                            Player = player,
                            ThreatLevel = threatLevel,
                            Distance = dist,
                            Reasons = reasons
                        })
                    end
                end
            end
        end
    end
    
    -- Sort by threat level
    table.sort(self.Threats, function(a, b)
        return a.ThreatLevel > b.ThreatLevel
    end)
    
    return self.Threats
end

function ThreatDetector:GetHighestThreat()
    self:ScanForThreats()
    if #self.Threats > 0 then
        return self.Threats[1]
    end
    return nil
end

function ThreatDetector:AlertIfThreat()
    local highestThreat = self:GetHighestThreat()
    if highestThreat and highestThreat.ThreatLevel >= 3 then
        sendNotification("THREAT!", highestThreat.Player.Name .. " - " .. table.concat(highestThreat.Reasons, ", "))
        return true
    end
    return false
end

-- Threat detection loop
Connections["ThreatDetectorLoop"] = RunService.Heartbeat:Connect(function()
    if ThreatDetector.Enabled then
        ThreatDetector:AlertIfThreat()
    end
end)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 78: REPLAY SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local ReplaySystem = {
    Recording = false,
    Frames = {},
    MaxFrames = 3000, -- ~5 minutes at 10fps
    PlaybackSpeed = 1,
    CurrentFrame = 0
}

function ReplaySystem:StartRecording()
    if self.Recording then return end
    
    self.Recording = true
    self.Frames = {}
    
    spawn(function()
        while self.Recording do
            local frameData = {
                Timestamp = tick(),
                Players = {}
            }
            
            for _, player in pairs(Players:GetPlayers()) do
                if player.Character then
                    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                    local hum = player.Character:FindFirstChildOfClass("Humanoid")
                    
                    if hrp and hum then
                        frameData.Players[player.Name] = {
                            CFrame = hrp.CFrame,
                            Health = hum.Health,
                            Velocity = hrp.Velocity
                        }
                    end
                end
            end
            
            table.insert(self.Frames, frameData)
            
            while #self.Frames > self.MaxFrames do
                table.remove(self.Frames, 1)
            end
            
            task.wait(0.1) -- 10fps recording
        end
    end)
    
    sendNotification("Replay", "Recording started...")
end

function ReplaySystem:StopRecording()
    self.Recording = false
    sendNotification("Replay", "Recording stopped. " .. #self.Frames .. " frames recorded.")
end

function ReplaySystem:GetFrameCount()
    return #self.Frames
end

function ReplaySystem:GetDuration()
    if #self.Frames < 2 then return 0 end
    return self.Frames[#self.Frames].Timestamp - self.Frames[1].Timestamp
end

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 79: ANTI-REPORT SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local AntiReportEnabled = false
local SuspiciousActions = 0
local MaxSuspiciousActions = 5

local function checkForSuspiciousActivity()
    -- Check for things that might trigger reports
    
    -- High speed
    local hum = getHumanoid()
    if hum and hum.WalkSpeed > 50 then
        SuspiciousActions = SuspiciousActions + 1
    end
    
    -- Flying
    local hrp = getHRP()
    if hrp then
        local rayParams = RaycastParams.new()
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        rayParams.FilterDescendantsInstances = {LocalCharacter}
        
        local result = Workspace:Raycast(hrp.Position, Vector3.new(0, -50, 0), rayParams)
        if not result then
            SuspiciousActions = SuspiciousActions + 1
        end
    end
    
    -- Reset counter periodically
    if SuspiciousActions > 0 then
        SuspiciousActions = SuspiciousActions - 0.1
    end
    
    -- If too suspicious, temporarily disable cheats
    if AntiReportEnabled and SuspiciousActions >= MaxSuspiciousActions then
        Settings.FlyEnabled = false
        Settings.NoclipEnabled = false
        
        local hum = getHumanoid()
        if hum then
            hum.WalkSpeed = 16
        end
        
        sendNotification("Anti-Report", "Suspicious activity detected! Temporarily disabling features...")
        SuspiciousActions = 0
    end
end

-- Anti-report loop
spawn(function()
    while true do
        if AntiReportEnabled then
            checkForSuspiciousActivity()
        end
        task.wait(1)
    end
end)

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 80: CONFIGURATION SAVE/LOAD SYSTEM
═══════════════════════════════════════════════════════════════════════════ ]]--

local ConfigSystem = {
    ConfigFolder = "BrunoConfigs",
    CurrentConfig = "default"
}

function ConfigSystem:SaveConfig(configName)
    configName = configName or self.CurrentConfig
    
    local configData = {
        -- Player settings
        WalkSpeed = Settings.WalkSpeed,
        JumpPower = Settings.JumpPower,
        Gravity = Settings.Gravity,
        FOV = Settings.FOV,
        
        -- Aimbot settings
        AimbotFOV = Settings.AimbotFOV,
        AimbotSmoothness = Settings.AimbotSmoothness,
        AimbotPart = Settings.AimbotPart,
        AimbotTeamCheck = Settings.AimbotTeamCheck,
        AimbotVisibleCheck = Settings.AimbotVisibleCheck,
        
        -- ESP settings
        ESPBoxColor = {Settings.ESPBoxColor.R * 255, Settings.ESPBoxColor.G * 255, Settings.ESPBoxColor.B * 255},
        ESPTracerOrigin = Settings.ESPTracerOrigin,
        
        -- Crosshair settings
        CrosshairSize = Settings.CrosshairSize,
        CrosshairGap = Settings.CrosshairGap,
        CrosshairThickness = Settings.CrosshairThickness,
        CrosshairDot = Settings.CrosshairDot,
        
        -- Other settings
        AutoCollectRadius = Settings.AutoCollectRadius,
        FlySpeed = Settings.FlySpeed
    }
    
    local success, err = pcall(function()
        if writefile then
            writefile(self.ConfigFolder .. "/" .. configName .. ".json", HttpService:JSONEncode(configData))
        end
    end)
    
    if success then
        sendNotification("Config", "Saved config: " .. configName)
    else
        sendNotification("Config", "Failed to save config!")
    end
end

function ConfigSystem:LoadConfig(configName)
    configName = configName or self.CurrentConfig
    
    local success, data = pcall(function()
        if readfile and isfile then
            if isfile(self.ConfigFolder .. "/" .. configName .. ".json") then
                return HttpService:JSONDecode(readfile(self.ConfigFolder .. "/" .. configName .. ".json"))
            end
        end
        return nil
    end)
    
    if success and data then
        -- Apply settings
        Settings.WalkSpeed = data.WalkSpeed or Settings.WalkSpeed
        Settings.JumpPower = data.JumpPower or Settings.JumpPower
        Settings.Gravity = data.Gravity or Settings.Gravity
        Settings.FOV = data.FOV or Settings.FOV
        
        Settings.AimbotFOV = data.AimbotFOV or Settings.AimbotFOV
        Settings.AimbotSmoothness = data.AimbotSmoothness or Settings.AimbotSmoothness
        Settings.AimbotPart = data.AimbotPart or Settings.AimbotPart
        Settings.AimbotTeamCheck = data.AimbotTeamCheck or Settings.AimbotTeamCheck
        Settings.AimbotVisibleCheck = data.AimbotVisibleCheck or Settings.AimbotVisibleCheck
        
        if data.ESPBoxColor then
            Settings.ESPBoxColor = Color3.fromRGB(data.ESPBoxColor[1], data.ESPBoxColor[2], data.ESPBoxColor[3])
        end
        Settings.ESPTracerOrigin = data.ESPTracerOrigin or Settings.ESPTracerOrigin
        
        Settings.CrosshairSize = data.CrosshairSize or Settings.CrosshairSize
        Settings.CrosshairGap = data.CrosshairGap or Settings.CrosshairGap
        Settings.CrosshairThickness = data.CrosshairThickness or Settings.CrosshairThickness
        Settings.CrosshairDot = data.CrosshairDot or Settings.CrosshairDot
        
        Settings.AutoCollectRadius = data.AutoCollectRadius or Settings.AutoCollectRadius
        Settings.FlySpeed = data.FlySpeed or Settings.FlySpeed
        
        -- Apply to game
        local hum = getHumanoid()
        if hum then
            hum.WalkSpeed = Settings.WalkSpeed
            hum.JumpPower = Settings.JumpPower
        end
        Camera.FieldOfView = Settings.FOV
        Workspace.Gravity = Settings.Gravity
        
        if FOVCircle then
            FOVCircle.Radius = Settings.AimbotFOV
        end
        
        sendNotification("Config", "Loaded config: " .. configName)
    else
        sendNotification("Config", "Failed to load config!")
    end
end

function ConfigSystem:DeleteConfig(configName)
    local success = pcall(function()
        if delfile and isfile then
            if isfile(self.ConfigFolder .. "/" .. configName .. ".json") then
                delfile(self.ConfigFolder .. "/" .. configName .. ".json")
            end
        end
    end)
    
    if success then
        sendNotification("Config", "Deleted config: " .. configName)
    end
end

function ConfigSystem:ListConfigs()
    local configs = {}
    
    pcall(function()
        if listfiles and isfolder then
            if isfolder(self.ConfigFolder) then
                for _, file in pairs(listfiles(self.ConfigFolder)) do
                    if string.sub(file, -5) == ".json" then
                        local name = string.gsub(file, self.ConfigFolder .. "/", "")
                        name = string.gsub(name, ".json", "")
                        table.insert(configs, name)
                    end
                end
            end
        end
    end)
    
    return configs
end

-- Create config folder
pcall(function()
    if makefolder and not isfolder(ConfigSystem.ConfigFolder) then
        makefolder(ConfigSystem.ConfigFolder)
    end
end)


--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 28: TELEPORT TAB - MAIN TELEPORT SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local TeleportSection = TeleportTab:CreateSection({
    ["Name"] = "|Teleport|",
    ["Side"] = "Left"
})

-- TP to Mouse (E key)
local TPToMouseEnabled = false
TeleportSection:AddToggle({
    ["Name"] = "| TP to Mouse ( E )",
    ["Callback"] = function(Value)
        TPToMouseEnabled = Value
    end
})

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.E and TPToMouseEnabled then
        local hrp = getHRP()
        if hrp and Mouse.Hit then
            hrp.CFrame = Mouse.Hit + Vector3.new(0, 3, 0)
        end
    end
end)

-- Coordinate Teleport
local TeleportX = 0
local TeleportY = 0
local TeleportZ = 0

TeleportSection:AddTextbox({
    ["Name"] = "X Coordinate",
    ["Value"] = "0",
    ["Callback"] = function(Value)
        TeleportX = tonumber(Value) or 0
    end
})

TeleportSection:AddTextbox({
    ["Name"] = "Y Coordinate",
    ["Value"] = "0",
    ["Callback"] = function(Value)
        TeleportY = tonumber(Value) or 0
    end
})

TeleportSection:AddTextbox({
    ["Name"] = "Z Coordinate",
    ["Value"] = "0",
    ["Callback"] = function(Value)
        TeleportZ = tonumber(Value) or 0
    end
})

TeleportSection:AddButton({
    ["Name"] = "Teleport to Coordinates",
    ["Callback"] = function()
        local hrp = getHRP()
        if hrp then
            hrp.CFrame = CFrame.new(TeleportX, TeleportY, TeleportZ)
            sendNotification("Teleported", string.format("Teleported to (%.1f, %.1f, %.1f)", TeleportX, TeleportY, TeleportZ))
        end
    end
})

TeleportSection:AddButton({
    ["Name"] = "Copy Current Coords",
    ["Callback"] = function()
        local hrp = getHRP()
        if hrp then
            local pos = hrp.Position
            local coords = string.format("%.2f, %.2f, %.2f", pos.X, pos.Y, pos.Z)
            copyToClipboard(coords)
        end
    end
})

-- Tween to Coordinates
local TweenSpeed = 50
TeleportSection:AddSlider({
    ["Min"] = 10,
    ["Max"] = 500,
    ["Name"] = "Tween Speed",
    ["Value"] = 50,
    ["Decimals"] = 0,
    ["Callback"] = function(Value)
        TweenSpeed = Value
    end
})

TeleportSection:AddButton({
    ["Name"] = "Tween to Coordinates",
    ["Callback"] = function()
        local hrp = getHRP()
        if hrp then
            local targetPos = Vector3.new(TeleportX, TeleportY, TeleportZ)
            local distance = (hrp.Position - targetPos).Magnitude
            local duration = distance / TweenSpeed
            
            tweenTo(targetPos, duration)
            sendNotification("Tweening", string.format("Tweening to coordinates (%.1fs)", duration))
        end
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 29: TELEPORT TAB - WAYPOINT SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local WaypointSection = TeleportTab:CreateSection({
    ["Name"] = "|Waypoints|",
    ["Side"] = "Right"
})

local WaypointName = ""

WaypointSection:AddTextbox({
    ["Name"] = "Waypoint Name",
    ["Value"] = "",
    ["Callback"] = function(Value)
        WaypointName = Value
    end
})

WaypointSection:AddButton({
    ["Name"] = "Save Waypoint",
    ["Callback"] = function()
        if WaypointName == "" then
            sendNotification("Error", "Please enter a waypoint name!")
            return
        end
        
        local hrp = getHRP()
        if hrp then
            Settings.SavedWaypoints[WaypointName] = hrp.CFrame
            Settings.WaypointCount = Settings.WaypointCount + 1
            sendNotification("Waypoint Saved", "Saved waypoint: " .. WaypointName)
            
            print("=== WAYPOINT SAVED ===")
            print("Name: " .. WaypointName)
            print("Position: " .. tostring(hrp.Position))
            print("======================")
        end
    end
})

WaypointSection:AddButton({
    ["Name"] = "Load Waypoint",
    ["Callback"] = function()
        if WaypointName == "" then
            sendNotification("Error", "Please enter a waypoint name!")
            return
        end
        
        local waypoint = Settings.SavedWaypoints[WaypointName]
        if waypoint then
            local hrp = getHRP()
            if hrp then
                hrp.CFrame = waypoint
                sendNotification("Waypoint Loaded", "Teleported to: " .. WaypointName)
            end
        else
            sendNotification("Error", "Waypoint not found: " .. WaypointName)
        end
    end
})

WaypointSection:AddButton({
    ["Name"] = "Delete Waypoint",
    ["Callback"] = function()
        if WaypointName == "" then
            sendNotification("Error", "Please enter a waypoint name!")
            return
        end
        
        if Settings.SavedWaypoints[WaypointName] then
            Settings.SavedWaypoints[WaypointName] = nil
            Settings.WaypointCount = Settings.WaypointCount - 1
            sendNotification("Waypoint Deleted", "Deleted waypoint: " .. WaypointName)
        else
            sendNotification("Error", "Waypoint not found!")
        end
    end
})

WaypointSection:AddButton({
    ["Name"] = "List All Waypoints",
    ["Callback"] = function()
        print("=== SAVED WAYPOINTS ===")
        local count = 0
        for name, cf in pairs(Settings.SavedWaypoints) do
            count = count + 1
            print(count .. ". " .. name .. " - " .. tostring(cf.Position))
        end
        if count == 0 then
            print("No waypoints saved!")
        end
        print("=======================")
        sendNotification("Waypoints", "Listed " .. count .. " waypoints (check output)")
    end
})

WaypointSection:AddButton({
    ["Name"] = "Clear All Waypoints",
    ["Callback"] = function()
        Settings.SavedWaypoints = {}
        Settings.WaypointCount = 0
        sendNotification("Waypoints Cleared", "All waypoints deleted!")
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 30: TELEPORT TAB - PLAYER TELEPORT SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local PlayerTPSection = TeleportTab:CreateSection({
    ["Name"] = "|Player Teleport|",
    ["Side"] = "Left"
})

local TPTargetName = ""
local TPAllDelay = 0.5

PlayerTPSection:AddTextbox({
    ["Name"] = "Player Name",
    ["Value"] = "",
    ["Callback"] = function(Value)
        TPTargetName = Value
    end
})

PlayerTPSection:AddButton({
    ["Name"] = "TP to Player",
    ["Callback"] = function()
        local target = findPlayer(TPTargetName)
        if target and target.Character then
            local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
            local myHRP = getHRP()
            
            if targetHRP and myHRP then
                myHRP.CFrame = targetHRP.CFrame * CFrame.new(0, 0, 5)
                sendNotification("Teleported", "Teleported to " .. target.Name)
            end
        else
            sendNotification("Error", "Player not found!")
        end
    end
})

PlayerTPSection:AddButton({
    ["Name"] = "Bring Player",
    ["Callback"] = function()
        local target = findPlayer(TPTargetName)
        if target and target.Character then
            local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
            local myHRP = getHRP()
            
            if targetHRP and myHRP then
                targetHRP.CFrame = myHRP.CFrame * CFrame.new(0, 0, 5)
                sendNotification("Brought", "Brought " .. target.Name .. " to you")
            end
        else
            sendNotification("Error", "Player not found!")
        end
    end
})

PlayerTPSection:AddButton({
    ["Name"] = "TP All to You",
    ["Callback"] = function()
        local myHRP = getHRP()
        if myHRP then
            local count = 0
            for i, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    local theirHRP = player.Character:FindFirstChild("HumanoidRootPart")
                    if theirHRP then
                        theirHRP.CFrame = myHRP.CFrame * CFrame.new(math.random(-5, 5), 0, math.random(-5, 5))
                        count = count + 1
                        task.wait(TPAllDelay)
                    end
                end
            end
            sendNotification("TP All", "Brought " .. count .. " players to you")
        end
    end
})

PlayerTPSection:AddButton({
    ["Name"] = "TP to Random Player",
    ["Callback"] = function()
        local players = {}
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                table.insert(players, player)
            end
        end
        
        if #players > 0 then
            local target = players[math.random(1, #players)]
            local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
            local myHRP = getHRP()
            
            if targetHRP and myHRP then
                myHRP.CFrame = targetHRP.CFrame * CFrame.new(0, 0, 5)
                sendNotification("Teleported", "Teleported to random player: " .. target.Name)
            end
        else
            sendNotification("Error", "No other players found!")
        end
    end
})

PlayerTPSection:AddSlider({
    ["Min"] = 0.1,
    ["Max"] = 3,
    ["Name"] = "TP All Delay",
    ["Value"] = 0.5,
    ["Decimals"] = 1,
    ["Callback"] = function(Value)
        TPAllDelay = Value
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 31: TELEPORT TAB - PATHFINDING SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local PathfindSection = TeleportTab:CreateSection({
    ["Name"] = "|Pathfinding|",
    ["Side"] = "Right"
})

local PathfindingEnabled = false
local CurrentPath = nil

PathfindSection:AddToggle({
    ["Name"] = "| Pathfind to Target",
    ["Callback"] = function(Value)
        PathfindingEnabled = Value
        
        if Value then
            local target = findPlayer(TPTargetName)
            if not target or not target.Character then
                sendNotification("Error", "No valid target!")
                return
            end
            
            spawn(function()
                while PathfindingEnabled and target and target.Character do
                    local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
                    local myHRP = getHRP()
                    local hum = getHumanoid()
                    
                    if targetHRP and myHRP and hum then
                        local path = PathfindingService:CreatePath({
                            AgentRadius = 2,
                            AgentHeight = 5,
                            AgentCanJump = true,
                            AgentJumpHeight = 10,
                            AgentMaxSlope = 45
                        })
                        
                        pcall(function()
                            path:ComputeAsync(myHRP.Position, targetHRP.Position)
                        end)
                        
                        if path.Status == Enum.PathStatus.Success then
                            local waypoints = path:GetWaypoints()
                            
                            for i, waypoint in pairs(waypoints) do
                                if not PathfindingEnabled then break end
                                
                                hum:MoveTo(waypoint.Position)
                                
                                if waypoint.Action == Enum.PathWaypointAction.Jump then
                                    hum:ChangeState(Enum.HumanoidStateType.Jumping)
                                end
                                
                                local timeout = hum.MoveToFinished:Wait()
                            end
                        end
                    end
                    
                    task.wait(0.5)
                end
            end)
        end
    end
})

PathfindSection:AddButton({
    ["Name"] = "Pathfind to Mouse",
    ["Callback"] = function()
        local myHRP = getHRP()
        local hum = getHumanoid()
        
        if myHRP and hum and Mouse.Hit then
            local path = PathfindingService:CreatePath({
                AgentRadius = 2,
                AgentHeight = 5,
                AgentCanJump = true,
                AgentJumpHeight = 10,
                AgentMaxSlope = 45
            })
            
            pcall(function()
                path:ComputeAsync(myHRP.Position, Mouse.Hit.Position)
            end)
            
            if path.Status == Enum.PathStatus.Success then
                local waypoints = path:GetWaypoints()
                
                spawn(function()
                    for i, waypoint in pairs(waypoints) do
                        hum:MoveTo(waypoint.Position)
                        
                        if waypoint.Action == Enum.PathWaypointAction.Jump then
                            hum:ChangeState(Enum.HumanoidStateType.Jumping)
                        end
                        
                        hum.MoveToFinished:Wait()
                    end
                    sendNotification("Pathfinding", "Reached destination!")
                end)
            else
                sendNotification("Error", "Could not find path!")
            end
        end
    end
})

PathfindSection:AddButton({
    ["Name"] = "Stop Pathfinding",
    ["Callback"] = function()
        PathfindingEnabled = false
        local hum = getHumanoid()
        if hum then
            hum:MoveTo(getHRP().Position)
        end
        sendNotification("Pathfinding", "Stopped!")
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 32: MISC TAB - CHARACTER EFFECTS SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local CharEffectsSection = MiscTab:CreateSection({
    ["Name"] = "|Character Effects|",
    ["Side"] = "Left"
})

-- Headless
CharEffectsSection:AddToggle({
    ["Name"] = "| Headless",
    ["Callback"] = function(Value)
        local head = getHead()
        if head then
            head.Transparency = Value and 1 or 0
            for _, v in pairs(head:GetDescendants()) do
                if v:IsA("Decal") or v:IsA("Texture") then
                    v.Transparency = Value and 1 or 0
                end
            end
        end
    end
})

-- Corrupted
CharEffectsSection:AddToggle({
    ["Name"] = "| Corrupted",
    ["Callback"] = function(Value)
        if LocalCharacter then
            for _, part in pairs(LocalCharacter:GetDescendants()) do
                if part:IsA("BasePart") then
                    if Value then
                        part.Material = Enum.Material.Neon
                        part.BrickColor = BrickColor.new("Really black")
                    else
                        part.Material = Enum.Material.Plastic
                    end
                end
            end
        end
    end
})

-- Spin
CharEffectsSection:AddToggle({
    ["Name"] = "| Spin",
    ["Callback"] = function(Value)
        Settings.SpinEnabled = Value
        
        if Value then
            Connections["Spin"] = RunService.RenderStepped:Connect(function()
                if Settings.SpinEnabled then
                    local hrp = getHRP()
                    if hrp then
                        hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(Settings.SpinSpeed), 0)
                    end
                end
            end)
        else
            if Connections["Spin"] then
                Connections["Spin"]:Disconnect()
                Connections["Spin"] = nil
            end
        end
    end
})

CharEffectsSection:AddSlider({
    ["Min"] = 1,
    ["Max"] = 50,
    ["Name"] = "Spin Speed",
    ["Value"] = 10,
    ["Decimals"] = 0,
    ["Callback"] = function(Value)
        Settings.SpinSpeed = Value
    end
})

-- Freeze Character
CharEffectsSection:AddToggle({
    ["Name"] = "| Freeze Character",
    ["Callback"] = function(Value)
        local hrp = getHRP()
        if hrp then
            hrp.Anchored = Value
        end
    end
})

-- Platform Stand
CharEffectsSection:AddToggle({
    ["Name"] = "| Platform Stand",
    ["Callback"] = function(Value)
        local hum = getHumanoid()
        if hum then
            hum.PlatformStand = Value
        end
    end
})

-- Sit Toggle
CharEffectsSection:AddToggle({
    ["Name"] = "| Sit",
    ["Callback"] = function(Value)
        local hum = getHumanoid()
        if hum then
            hum.Sit = Value
        end
    end
})

-- Fake Death
CharEffectsSection:AddButton({
    ["Name"] = "| Fake Death",
    ["Callback"] = function()
        local hum = getHumanoid()
        if hum then
            hum:ChangeState(Enum.HumanoidStateType.Ragdoll)
            task.wait(3)
            hum:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
    end
})

-- Rainbow Character
local RainbowEnabled = false
CharEffectsSection:AddToggle({
    ["Name"] = "| Rainbow Character",
    ["Callback"] = function(Value)
        RainbowEnabled = Value
        
        if Value then
            spawn(function()
                local hue = 0
                while RainbowEnabled do
                    hue = hue + 0.01
                    if hue > 1 then hue = 0 end
                    
                    local color = Color3.fromHSV(hue, 1, 1)
                    
                    if LocalCharacter then
                        for _, part in pairs(LocalCharacter:GetDescendants()) do
                            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                                part.Color = color
                            end
                        end
                    end
                    
                    task.wait()
                end
            end)
        end
    end
})

-- Invisible Arms
CharEffectsSection:AddToggle({
    ["Name"] = "| Invisible Arms",
    ["Callback"] = function(Value)
        if LocalCharacter then
            for _, part in pairs(LocalCharacter:GetDescendants()) do
                if part:IsA("BasePart") and (string.find(part.Name, "Arm") or string.find(part.Name, "Hand")) then
                    part.Transparency = Value and 1 or 0
                end
            end
        end
    end
})

-- Invisible Legs
CharEffectsSection:AddToggle({
    ["Name"] = "| Invisible Legs",
    ["Callback"] = function(Value)
        if LocalCharacter then
            for _, part in pairs(LocalCharacter:GetDescendants()) do
                if part:IsA("BasePart") and (string.find(part.Name, "Leg") or string.find(part.Name, "Foot")) then
                    part.Transparency = Value and 1 or 0
                end
            end
        end
    end
})


--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 81: MISC TAB - CHAT SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local ChatSection = MiscTab:CreateSection({
    ["Name"] = "|Chat|",
    ["Side"] = "Right"
})

-- Chat Spam
local ChatSpamMessage = ""
local ChatSpamInterval = 1

ChatSection:AddToggle({
    ["Name"] = "| Chat Spam",
    ["Callback"] = function(Value)
        Settings.ChatSpamEnabled = Value
        
        if Value then
            spawn(function()
                while Settings.ChatSpamEnabled do
                    if ChatSpamMessage ~= "" then
                        pcall(function()
                            local chatRemote = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
                            if chatRemote then
                                local sayRemote = chatRemote:FindFirstChild("SayMessageRequest")
                                if sayRemote then
                                    sayRemote:FireServer(ChatSpamMessage, "All")
                                end
                            end
                        end)
                    end
                    task.wait(ChatSpamInterval)
                end
            end)
        end
    end
})

ChatSection:AddTextbox({
    ["Name"] = "Spam Message",
    ["Value"] = "",
    ["Callback"] = function(Value)
        ChatSpamMessage = Value
    end
})

ChatSection:AddSlider({
    ["Min"] = 0.5,
    ["Max"] = 10,
    ["Name"] = "Spam Interval",
    ["Value"] = 1,
    ["Decimals"] = 1,
    ["Callback"] = function(Value)
        ChatSpamInterval = Value
    end
})

-- Send Single Message
local SingleMessage = ""
ChatSection:AddTextbox({
    ["Name"] = "Single Message",
    ["Value"] = "",
    ["Callback"] = function(Value)
        SingleMessage = Value
    end
})

ChatSection:AddButton({
    ["Name"] = "Send Message",
    ["Callback"] = function()
        if SingleMessage ~= "" then
            pcall(function()
                local chatRemote = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
                if chatRemote then
                    local sayRemote = chatRemote:FindFirstChild("SayMessageRequest")
                    if sayRemote then
                        sayRemote:FireServer(SingleMessage, "All")
                    end
                end
            end)
        end
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 82: MISC TAB - TOOL MODS SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local ToolModsSection = MiscTab:CreateSection({
    ["Name"] = "|Tool Mods|",
    ["Side"] = "Right"
})

-- Extended Reach
local ReachAmount = 50
ToolModsSection:AddToggle({
    ["Name"] = "| Extended Reach",
    ["Callback"] = function(Value)
        if Value then
            Connections["ExtendedReach"] = RunService.Heartbeat:Connect(function()
                for _, tool in pairs(getAllTools()) do
                    local handle = tool:FindFirstChild("Handle")
                    if handle then
                        handle.Size = Vector3.new(ReachAmount, ReachAmount, ReachAmount)
                        handle.Transparency = 1
                        handle.Massless = true
                    end
                end
            end)
        else
            if Connections["ExtendedReach"] then
                Connections["ExtendedReach"]:Disconnect()
                Connections["ExtendedReach"] = nil
            end
        end
    end
})

ToolModsSection:AddSlider({
    ["Min"] = 10,
    ["Max"] = 200,
    ["Name"] = "Reach Amount",
    ["Value"] = 50,
    ["Decimals"] = 0,
    ["Callback"] = function(Value)
        ReachAmount = Value
    end
})

-- Auto Activate Tool
ToolModsSection:AddToggle({
    ["Name"] = "| Auto Activate Tool",
    ["Callback"] = function(Value)
        if Value then
            Connections["AutoActivate"] = RunService.Heartbeat:Connect(function()
                local tool = getEquippedTool()
                if tool then
                    pcall(function()
                        tool:Activate()
                    end)
                end
            end)
        else
            if Connections["AutoActivate"] then
                Connections["AutoActivate"]:Disconnect()
                Connections["AutoActivate"] = nil
            end
        end
    end
})

-- Equip All Tools
ToolModsSection:AddButton({
    ["Name"] = "Equip All Tools",
    ["Callback"] = function()
        local backpack = getBackpack()
        if backpack then
            local count = 0
            for _, tool in pairs(backpack:GetChildren()) do
                if tool:IsA("Tool") then
                    tool.Parent = LocalCharacter
                    count = count + 1
                end
            end
            sendNotification("Tools", "Equipped " .. count .. " tools")
        end
    end
})

-- Unequip All Tools
ToolModsSection:AddButton({
    ["Name"] = "Unequip All Tools",
    ["Callback"] = function()
        local backpack = getBackpack()
        if backpack and LocalCharacter then
            local count = 0
            for _, tool in pairs(LocalCharacter:GetChildren()) do
                if tool:IsA("Tool") then
                    tool.Parent = backpack
                    count = count + 1
                end
            end
            sendNotification("Tools", "Unequipped " .. count .. " tools")
        end
    end
})

-- Drop All Tools
ToolModsSection:AddButton({
    ["Name"] = "Drop All Tools",
    ["Callback"] = function()
        local hrp = getHRP()
        local count = 0
        
        -- From character
        if LocalCharacter then
            for _, tool in pairs(LocalCharacter:GetChildren()) do
                if tool:IsA("Tool") then
                    tool.Parent = Workspace
                    local handle = tool:FindFirstChild("Handle")
                    if handle and hrp then
                        handle.CFrame = hrp.CFrame * CFrame.new(0, 0, -5)
                    end
                    count = count + 1
                end
            end
        end
        
        -- From backpack
        local backpack = getBackpack()
        if backpack then
            for _, tool in pairs(backpack:GetChildren()) do
                if tool:IsA("Tool") then
                    tool.Parent = Workspace
                    local handle = tool:FindFirstChild("Handle")
                    if handle and hrp then
                        handle.CFrame = hrp.CFrame * CFrame.new(0, 0, -5)
                    end
                    count = count + 1
                end
            end
        end
        
        sendNotification("Tools", "Dropped " .. count .. " tools")
    end
})

-- Clone Equipped Tool
ToolModsSection:AddButton({
    ["Name"] = "Clone Equipped Tool",
    ["Callback"] = function()
        local tool = getEquippedTool()
        if tool then
            local clone = tool:Clone()
            clone.Parent = getBackpack()
            sendNotification("Cloned", "Cloned " .. tool.Name)
        else
            sendNotification("Error", "No tool equipped!")
        end
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 83: SETTINGS TAB - SCRIPT INFO SECTION
═══════════════════════════════════════════════════════════════════════════ ]]--

local InfoSection = SettingsTab:CreateSection({
    ["Name"] = "|Script Info|",
    ["Side"] = "Left"
})

InfoSection:AddButton({
    ["Name"] = "Print Script Info",
    ["Callback"] = function()
        print("╔═══════════════════════════════════════════════════════════════╗")
        print("║           BRUNO | SOUTH BRONX - FULL FEATURE SCRIPT           ║")
        print("╠═══════════════════════════════════════════════════════════════╣")
        print("║  Game: Bruno | South Bronx (PlaceId: 3351674303)              ║")
        print("║  UI Library: Pepsi's UI Library                               ║")
        print("║  Lines: 10,000+                                               ║")
        print("╠═══════════════════════════════════════════════════════════════╣")
        print("║  KEYBINDS:                                                    ║")
        print("║  RShift - Toggle UI                                           ║")
        print("║  V - Toggle Fly                                               ║")
        print("║  T - Forward Teleport                                         ║")
        print("║  X - Toggle Invisible                                         ║")
        print("║  N - Toggle Noclip                                            ║")
        print("║  E - TP to Mouse                                              ║")
        print("║  L - Stop All Loops                                           ║")
        print("╠═══════════════════════════════════════════════════════════════╣")
        print("║  PASTEBINS LOADED:                                            ║")
        print("║  Semi GodMode, Hitbox Expander, Forward Teleport              ║")
        print("║  Fly, Invisible, Box ESP, Name ESP, Health Bar                ║")
        print("║  Distance ESP, Skeleton, Arrows, Inventory ESP                ║")
        print("║  Radar, FullBright, Silent Aim, Rob Farm                      ║")
        print("║  Server Hop, Anti AFK, Hide Name, Low GFX                     ║")
        print("║  Enable Reset, Vehicle Mod                                    ║")
        print("╚═══════════════════════════════════════════════════════════════╝")
    end
})

InfoSection:AddButton({
    ["Name"] = "Copy Discord Invite",
    ["Callback"] = function()
        copyToClipboard("discord.gg/skiihub")
        sendNotification("Copied", "Discord invite copied!")
    end
})

InfoSection:AddButton({
    ["Name"] = "Destroy Script",
    ["Callback"] = function()
        cleanUp()
        pcall(function()
            MainWindow:Destroy()
        end)
        sendNotification("Script", "Script destroyed!")
    end
})

--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 84: FINAL INITIALIZATION
═══════════════════════════════════════════════════════════════════════════ ]]--

-- Initialize Auto Farm Manager
AutoFarmManager:Start()

-- Initialize any saved configs
pcall(function()
    ConfigSystem:LoadConfig("default")
end)

-- Final print message
print("")
print("╔═══════════════════════════════════════════════════════════════════════════════╗")
print("║                                                                               ║")
print("║   ██████╗ ██████╗ ██╗   ██╗███╗   ██╗ ██████╗                                 ║")
print("║   ██╔══██╗██╔══██╗██║   ██║████╗  ██║██╔═══██╗                                ║")
print("║   ██████╔╝██████╔╝██║   ██║██╔██╗ ██║██║   ██║                                ║")
print("║   ██╔══██╗██╔══██╗██║   ██║██║╚██╗██║██║   ██║                                ║")
print("║   ██████╔╝██║  ██║╚██████╔╝██║ ╚████║╚██████╔╝                                ║")
print("║   ╚═════╝ ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝                                 ║")
print("║                                                                               ║")
print("║                    SOUTH BRONX SCRIPT LOADED SUCCESSFULLY!                    ║")
print("║                              10,000+ Lines Edition                            ║")
print("║                                                                               ║")
print("╠═══════════════════════════════════════════════════════════════════════════════╣")
print("║                                                                               ║")
print("║   FEATURES LOADED:                                                            ║")
print("║   ├── General Tab: Player Mods, Gun Mods, Target System                      ║")
print("║   ├── Aimbot Tab: Silent Aim, FOV Circle, Smoothness, Prediction             ║")
print("║   ├── Visuals Tab: ESP, Chams, Highlights, Crosshair, Radar                  ║")
print("║   ├── Farm Tab: Auto Farms, ATM Teleports, Car Mods                          ║")
print("║   ├── Teleport Tab: Coords, Waypoints, Player TP, Pathfinding                ║")
print("║   ├── Misc Tab: Character Effects, Chat, Tools, Anti-Cheat                   ║")
print("║   └── Settings Tab: Server, Debug, Config Save/Load                          ║")
print("║                                                                               ║")
print("╠═══════════════════════════════════════════════════════════════════════════════╣")
print("║                                                                               ║")
print("║   KEYBINDS:                                                                   ║")
print("║   RShift = Toggle UI     |  V = Fly        |  T = Forward TP                 ║")
print("║   X = Invisible          |  N = Noclip     |  E = TP to Mouse                ║")
print("║   L = Stop Loops         |  MB2 = Aimbot                                     ║")
print("║                                                                               ║")
print("╠═══════════════════════════════════════════════════════════════════════════════╣")
print("║                                                                               ║")
print("║   ALL 20+ ORIGINAL PASTEBINS LOADED:                                         ║")
print("║   ├── Player: GodMode, Hitbox, TP, Fly, Invisible                            ║")
print("║   ├── ESP: Box, Name, Health, Distance, Skeleton, Arrows, Inventory, Radar   ║")
print("║   ├── Aimbot: Silent Aim & Wall Bang                                         ║")
print("║   ├── Farm: Rob Farm                                                         ║")
print("║   └── Server: Server Hop, Anti AFK, Hide Name, Reset Button, Low GFX         ║")
print("║                                                                               ║")
print("╚═══════════════════════════════════════════════════════════════════════════════╝")
print("")

-- Startup notification
sendNotification("Bruno Loaded!", "10,000+ line script loaded successfully!")

-- Connect keybind listener
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed then
        KeybindManager:ProcessInput(input)
    end
end)

-- Game-specific initialization
if GamePlaceId == 3351674303 then
    sendNotification("Game Detected", "Bruno | South Bronx detected!")
    
    -- Try to find game-specific elements
    spawn(function()
        task.wait(2)
        findATMs()
        findGameLocations()
    end)
end

-- Player count notification
local playerCount = #Players:GetPlayers()
sendNotification("Players", "There are " .. playerCount .. " players in this server")

-- End of script
print("[Bruno] Full script initialization complete!")
print("[Bruno] Total features loaded: 80+ sections")
print("[Bruno] Enjoy!")


--[[ ═══════════════════════════════════════════════════════════════════════════
    SECTION 85: ADDITIONAL UTILITY FUNCTIONS
═══════════════════════════════════════════════════════════════════════════ ]]--

-- Get server region
local function getServerRegion()
    local region = "Unknown"
    pcall(function()
        local ping = LocalPlayer:GetNetworkPing()
        if ping < 0.05 then
            region = "Local/Very Close"
        elseif ping < 0.1 then
            region = "Near"
        elseif ping < 0.2 then
            region = "Medium Distance"
        else
            region = "Far"
        end
    end)
    return region
end

-- Get server age
local function getServerAge()
    local uptime = Workspace.DistributedGameTime
    local hours = math.floor(uptime / 3600)
    local minutes = math.floor((uptime % 3600) / 60)
    local seconds = math.floor(uptime % 60)
    return string.format("%02d:%02d:%02d", hours, minutes, seconds)
end

-- Check if player is alive
local function isPlayerAlive(player)
    if player and player.Character then
        local hum = player.Character:FindFirstChildOfClass("Humanoid")
        return hum and hum.Health > 0
    end
    return false
end

-- Get player team color
local function getTeamColor(player)
    if player.Team then
        return player.TeamColor.Color
    end
    return Color3.fromRGB(255, 255, 255)
end

-- Get player health percentage
local function getHealthPercent(player)
    if player and player.Character then
        local hum = player.Character:FindFirstChildOfClass("Humanoid")
        if hum then
            return (hum.Health / hum.MaxHealth) * 100
        end
    end
    return 0
end

-- Get equipped weapon name
local function getEquippedWeaponName(player)
    if player and player.Character then
        for _, item in pairs(player.Character:GetChildren()) do
            if item:IsA("Tool") then
                return item.Name
            end
        end
    end
    return "None"
end

-- Calculate aim angle
local function getAimAngle(targetPosition)
    local screenPos = Camera:WorldToScreenPoint(targetPosition)
    local mousePos = UserInputService:GetMouseLocation()
    local direction = Vector2.new(screenPos.X, screenPos.Y) - mousePos
    return math.atan2(direction.Y, direction.X)
end

-- Get velocity direction as string
local function getVelocityDirection(player)
    if player and player.Character then
        local hrp = player.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local vel = hrp.Velocity
            if vel.Magnitude < 1 then
                return "Stationary"
            elseif vel.Y > 10 then
                return "Ascending"
            elseif vel.Y < -10 then
                return "Falling"
            else
                return "Moving"
            end
        end
    end
    return "Unknown"
end

-- Print detailed server info
local function printServerInfo()
    print("╔═══════════════════════════════════════╗")
    print("║         SERVER INFORMATION            ║")
    print("╠═══════════════════════════════════════╣")
    print("║ Place ID: " .. tostring(GamePlaceId))
    print("║ Job ID: " .. string.sub(GameJobId, 1, 20) .. "...")
    print("║ Players: " .. #Players:GetPlayers() .. "/" .. Players.MaxPlayers)
    print("║ Server Age: " .. getServerAge())
    print("║ Region Estimate: " .. getServerRegion())
    print("║ Your Ping: " .. math.floor(LocalPlayer:GetNetworkPing() * 1000) .. "ms")
    print("╚═══════════════════════════════════════╝")
end

-- Print detailed player info
local function printDetailedPlayerInfo(player)
    if not player then return end
    
    print("╔═══════════════════════════════════════╗")
    print("║         PLAYER INFORMATION            ║")
    print("╠═══════════════════════════════════════╣")
    print("║ Name: " .. player.Name)
    print("║ Display: " .. player.DisplayName)
    print("║ User ID: " .. player.UserId)
    print("║ Account Age: " .. player.AccountAge .. " days")
    print("║ Alive: " .. tostring(isPlayerAlive(player)))
    print("║ Health: " .. string.format("%.1f%%", getHealthPercent(player)))
    print("║ Weapon: " .. getEquippedWeaponName(player))
    print("║ Movement: " .. getVelocityDirection(player))
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local pos = player.Character.HumanoidRootPart.Position
        print("║ Position: " .. string.format("%.1f, %.1f, %.1f", pos.X, pos.Y, pos.Z))
    end
    print("╚═══════════════════════════════════════╝")
end

-- Script version info
local ScriptVersion = "10.0.0"
local ScriptBuild = "Full-Feature"
local ScriptDate = "2025"

print("[Bruno] Version: " .. ScriptVersion)
print("[Bruno] Build: " .. ScriptBuild)
print("[Bruno] Script Lines: 10,000+")

--[[ ═══════════════════════════════════════════════════════════════════════════
    END OF SCRIPT - BRUNO | SOUTH BRONX FULL FEATURE (10,000+ LINES)
═══════════════════════════════════════════════════════════════════════════ ]]--
